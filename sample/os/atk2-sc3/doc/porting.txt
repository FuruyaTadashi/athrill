
		TOPPERS/ATK2-SC3
		ターゲット依存部 ポーティングガイド

このドキュメントは，TOPPERS/ATK2-SC3を，未サポートのターゲットシステム
にポーティングするために必要となるターゲット依存部の実装方法を説明する
ものである．

----------------------------------------------------------------------
TOPPERS ATK2
    Toyohashi Open Platform for Embedded Real-Time Systems
    Automotive Kernel Version 2

Copyright (C) 2011-2015 by Center for Embedded Computing Systems
            Graduate School of Information Science, Nagoya Univ., JAPAN
Copyright (C) 2011-2015 by FUJI SOFT INCORPORATED, JAPAN
Copyright (C) 2011-2013 by Spansion LLC, USA
Copyright (C) 2011-2015 by NEC Communication Systems, Ltd., JAPAN
Copyright (C) 2011-2015 by Panasonic Advanced Technology Development Co., Ltd., JAPAN
Copyright (C) 2011-2014 by Renesas Electronics Corporation, JAPAN
Copyright (C) 2011-2015 by Sunny Giken Inc., JAPAN
Copyright (C) 2011-2015 by TOSHIBA CORPORATION, JAPAN
Copyright (C) 2011-2015 by Witz Corporation
Copyright (C) 2014-2015 by AISIN COMCRUISE Co., Ltd., JAPAN
Copyright (C) 2014-2015 by eSOL Co.,Ltd., JAPAN
Copyright (C) 2014-2015 by SCSK Corporation, JAPAN
Copyright (C) 2015 by SUZUKI MOTOR CORPORATION

上記著作権者は，以下の (1)〜(3)の条件を満たす場合に限り，本ドキュメ
ント（本ドキュメントを改変したものを含む．以下同じ）を使用・複製・改
変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
(1) 本ドキュメントを利用する場合には，上記の著作権表示，この利用条件
    および下記の無保証規定が，そのままの形でドキュメント中に含まれて
    いること．
(2) 本ドキュメントを改変する場合には，ドキュメントを改変した旨の記述
    を，改変後のドキュメント中に含めること．ただし，改変後のドキュメ
    ントが，TOPPERSプロジェクト指定の開発成果物である場合には，この限
    りではない．
(3) 本ドキュメントの利用により直接的または間接的に生じるいかなる損害
    からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，
    本ドキュメントのユーザまたはエンドユーザからのいかなる理由に基づ
    く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

本ドキュメントは，AUTOSAR（AUTomotive Open System ARchitecture）仕様
に基づいている．上記の許諾は，AUTOSARの知的財産権を許諾するものではな
い．AUTOSARは，AUTOSAR仕様に基づいたソフトウェアを商用目的で利用する
者に対して，AUTOSARパートナーになることを求めている．

本ドキュメントは，無保証で提供されているものである．上記著作権者およ
びTOPPERSプロジェクトは，本ドキュメントに関して，特定の使用目的に対す
る適合性も含めて，いかなる保証も行わない．また，本ドキュメントの利用
により直接的または間接的に生じたいかなる損害に関しても，その責任を負
わない．

$Id: porting.txt 517 2015-12-24 10:41:42Z witz-itoyo $
----------------------------------------------------------------------

○目次

◎０．本マニュアルの位置づけ
１．共通事項
	1.1 ターゲット依存部の構成
	1.2 多重インクルードの防止
	1.3 アセンブリ言語とのヘッダファイルの共用 
	1.4 インクルード記述の方法
	1.5 クリティカルセクションの出入処理の実現に関する制約
２．システム構築環境のターゲット依存部
	2.1 ターゲット略称とターゲット依存部のディレクトリ
	2.2 Makefileのターゲット依存部
	2.3 開発環境名とコマンド名の設定
	2.4 コンパイルオプションとオブジェクトファイルの設定
	2.5 オフセットファイルの生成方法
		2.5.1 ジェネレータを用いる方法
	○2.6 リンク方法の設定
	○2.7 依存関係の定義
	2.8 その他の設定
３．AUTOSAR共通定義のターゲット依存部
	3.1 整数型の最大値・最小値・ビット数
	3.2 整数型
	3.3 論理型，論理型の値
	3.4 その他の型
	3.5 コンパイラの拡張機能のためのマクロ定義
	3.6 標準的な定義の上書き
４．システムインタフェースレイヤ（SIL）のターゲット依存部
	4.1 全割込み禁止状態の管理
	4.2 プロセッサのエンディアン
	4.3 I/O空間アクセス関数
５．カーネルAPIのターゲット依存部
	5.1 メモリ領域確保のための型定義
	5.2 メモリ領域確保のためのマクロ
	○5.3 オブジェクト型の上書き
６．カーネル実装のターゲット依存部
	6.1 カーネル実装のターゲット依存部の共通事項
		○6.1.1 カーネル実装のターゲット依存部の構成要素
		6.1.2 ターゲット依存部の関数の命名規則
	6.2 トレースログ機能への対応
	6.3 システム状態の管理
		6.3.1 全割込み禁止状態の管理
		6.3.2 コンテキストの管理
		6.3.3 OS割込み禁止状態の管理
	6.4 割込みに関連するシステム状態の管理
		6.4.1 割込み優先度マスクの管理
		6.4.2 割込みハンドラの先頭処理と末尾処理
		6.4.3 個別割込み禁止状態の管理
	6.5 タスクディスパッチャ
		○6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック
		6.5.2 ディスパッチャ本体
		6.5.3 タスクコンテキストからのディスパッチ
		6.5.4 ディスパッチャの動作開始
		○6.5.5 現在のコンテキストを捨ててディスパッチ
		○6.5.6 タスクの起動処理
	6.6 割込みハンドラ
		○6.6.1 割込みハンドラの出入口処理
		6.6.2 割込み要求ラインの属性の設定
		○6.6.3 割込み管理機能の初期化処理の変更
		6.6.4 デフォルトのC2ISR
		6.6.5 カーネル管理外の割込み
		6.6.6 DisableAllInterrupts/EnableAllInterruptsの処理内容の変更
		◎6.6.7 割込み禁止解除
	6.7 スタックモニタリング
		◎6.7.1 ディスパッチャとC2ISRの出入口処理でのスタックモニタリング
		◎6.7.2 信頼関数実行の出口処理でのスタックモニタリング
	○6.8 CPU例外ハンドラ
	◎6.9 ソフトウェア割込みハンドラ
	◎6.10 信頼OSAPと非信頼OSAPからのシステムサービス呼出し
		◎6.10.1 システムサービス呼出しの定義
		◎6.10.2 信頼OSAPからのシステムサービス呼出し
		◎6.10.3 非信頼OSAPからのシステムサービス呼出し
		◎6.10.4 ターゲット依存システムサービスの追加
	◎6.11 メモリ保護機構（MPU）制御
		◎6.11.1 スタックのMPU設定情報ブロック（STKMPUINFOB）
		◎6.11.2 OSAP固有MPU設定情報ブロック（OSAPMPUINFOB）
		◎6.11.3 MPU初期化処理
		◎6.11.4 OSAP固有MPU情報設定処理
		◎6.11.5 MPU依存のバックグラウンド領域チェック
	◎6.12 メモリ管理のチューニング
		◎6.12.1 メモリオブジェクトの管理
		◎6.12.2 メモリアクセス権チェックのためのマクロ
	6.13 エラーフック，シャットダウンフック呼び出し
	○6.14 カーネルの起動・終了とスタック領域など
	6.15 カーネル内部のチューニング
		6.15.1 ビットマップサーチ
	6.16 カーネル実装に関するその他の定義
		6.16.1 エラーチェック方法の指定
		6.16.2 非タスクコンテキスト用のスタック領域
		6.16.3 空ラベルの定義
		○6.16.4 各スタックのデフォルト値
		○6.16.5 スタックマジックナンバー領域操作マクロの定義
		◎6.16.6 標準以外メモリリージョン属性の定義
	6.17 トレースログ機能に関する設定
		6.17.1 取得できるトレースログの種類とマクロ
		6.17.2 トレースログ記録のサンプルコード
	◎6.18 信頼フック，シャットダウンフックの強制終了
	◎6.19 コア起動
	◎6.20 フックの確認
	◎6.21 スタック切り替え
	◎6.22 非信頼フックルーチンスタック領域
	6.23 ハードウェアカウンタ
		6.23.1 ハードウェアカウンタのファイル構成
		6.23.2 ハードウェアカウンタの情報提供
	◎6.24 OSAP強制終了
７．ジェネレータ設定ファイルのターゲット依存部
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2のテンプレートファイルのターゲット依存部
		○7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数
		○7.2.2 ターゲット非依存部で定義される変数
	7.3 パス3のテンプレートファイルのターゲット依存部
		○7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数
	◎7.4 パス4のテンプレートファイルのターゲット依存部
		◎7.4.1 ターゲット非依存部をインクルードする前に定義すべき変数
	○7.5 cfg1_out.cのリンクに必要なスタブの定義ファイル
	◎7.6 data/bssセクション初期化ブロックの生成
８．システムモジュール等のターゲット依存部
	8.1 システムモジュールのターゲット依存部
	○8.2 システムログ機能のターゲット依存定義
	8.3 シリアルインタフェースドライバのターゲット依存部
		8.3.1 変数，データ型，管理関数
		8.3.2 デバイスサービスルーチン
		8.3.3 コールバックルーチン
	8.4 カーネル起動メッセージの出力のターゲット依存定義
	8.5 サンプルプログラムとテストプログラムのターゲット依存定義
	8.6 実行時間分布集計モジュールのターゲット依存定義
	8.7 タイマドライバ
		8.7.1 タイマドライバのファイル構成
		8.7.2 ソフトウェアカウンタの定義
		8.7.3 時間型の定義
		8.7.4 タイマの初期化・終了処理・割込み処理
		8.7.5 現在の時刻の取得
９．その他
	9.1 ドキュメント
１０．リファレンス
	○10.1 ターゲット依存部のファイル一覧

○がついている項目はATK2-SC1から変更があった箇所を，◎はATK2-SC3で
新規に追加された箇所を示し，それぞれ差分のみを記述している．


０．本マニュアルの位置づけ
TOPPERS/ATK2-SC3は，TOPPERS/ATK2-SC1をベースとしているため，多くのポー
ティング項目はTOPPERS/ATK2-SC1と同一である．本ドキュメントでは，TOPPER
S/ATK2-SC1と異なる点について説明する．そのため，まずTOPPERS/ATK2-SC1の
ポーティングガイドを参照の後，本ドキュメントを参照すること．


１．共通事項

1.1 ターゲット依存部の構成

ATK2-SC1から変更なし．

1.2 多重インクルードの防止

ATK2-SC1から変更なし．

1.3 アセンブリ言語とのヘッダファイルの共用 

ATK2-SC1から変更なし．

1.4 インクルード記述の方法

ATK2-SC1から変更なし．

1.5 クリティカルセクションの出入処理の実現に関する制約

ATK2-SC1から変更なし．

２．システム構築環境のターゲット依存部

2.1 ターゲット略称とターゲット依存部のディレクトリ

ATK2-SC1から変更なし．

2.2 Makefileのターゲット依存部

ATK2-SC1から変更なし．

2.3 開発環境名とコマンド名の設定

ATK2-SC1から変更なし．

2.4 コンパイルオプションとオブジェクトファイルの設定

ATK2-SC1から変更なし．

2.5 オフセットファイルの生成方法

ATK2-SC1から変更なし．

2.6 リンク方法の設定

ATK2-SC3カーネルは，メモリの最適化を行うため，以下のマクロは，使用でき
ない．

(2-6-2) TEXT_START_ADDRESS		テキストセクションの先頭番地
(2-6-3) DATA_START_ADDRESS		データセクションの先頭番地

2.7 依存関係の定義

ジェネレータの各パスに対して，ターゲット依存のファイルへの依存関係を定
義する．具体的には，パス1，パス2，パス3，パス4が依存するファイルを，そ
れぞれcfg1_out.c，Os_Lcfg.timestamp，kernel_mem3.c，kernel_mem.c，
$(OBJFILE)に対する依存関係の形で記述する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，
以下の記述を含める必要がある．

----------------------------------------
kernel_mem3.c: $(TARGETDIR)/target_mem.tf
kernel_mem.c: $(TARGETDIR)/target_mem2.tf $(TARGETDIR)/target_check.tf
----------------------------------------

2.8 その他の設定

ATK2-SC1から変更なし．

３．AUTOSAR共通定義のターゲット依存部

3.1 整数型の最大値・最小値・ビット数

ATK2-SC1から変更なし．

3.2 整数型

ATK2-SC1から変更なし．

3.3 論理型，論理型の値

ATK2-SC1から変更なし．

3.4 その他の型

ATK2-SC1から変更なし．

3.5 コンパイラの拡張機能のためのマクロ定義

ATK2-SC1から変更なし．

3.6 標準的な定義の上書き

ATK2-SC1から変更なし．

４．システムインタフェースレイヤ（SIL）のターゲット依存部

4.1 全割込み禁止状態の管理

ATK2-SC1から変更なし．

4.2 プロセッサのエンディアン

ATK2-SC1から変更なし．

５．カーネルAPIのターゲット依存部

5.1 メモリ領域確保のための型定義

ATK2-SC1から変更なし．

5.2 メモリ領域確保のためのマクロ

ATK2-SC1から変更なし．

5.3 オブジェクト型の上書き

(5-3-1) OMIT_DATA_TYPE (オプション)

OMIT_DATA_TYPEマクロをターゲット依存部で定義した場合は，一部のオブジェ
クトの型をターゲット依存部で定義することができる．

(5-3-15) TrustedFunctionIndexType (オプション，デフォルトはuint32)
(5-3-16) IocType              (オプション，デフォルトはuint32)
(5-3-17) SenderIdType         (オプション，デフォルトはuint8)


６．カーネル実装のターゲット依存部

6.1 カーネル実装のターゲット依存部の共通事項

6.1.1 カーネル実装のターゲット依存部の構成要素

(c) ジェネレータ設定ファイル

ジェネレータの設定ファイルのターゲット依存部を，target_def.csv，
target.tf，target_mem.tf，target_mem2.tf，target_check.tfに用意する．
ジェネレータ設定ファイルの記述方法については，７章で説明する．

6.1.2 ターゲット依存部の関数の命名規則

ATK2-SC1から変更なし．

6.2 トレースログ機能への対応

ATK2-SC1から変更なし．

6.3 システム状態の管理

6.3.1 全割込み禁止状態の管理

ATK2-SC1から変更なし．

6.3.2 コンテキストの管理

ATK2-SC1から変更なし．

6.3.3 OS割込み禁止状態の管理

ATK2-SC1から変更なし．

6.4 割込みに関連するシステム状態の管理

6.4.1 割込み優先度マスクの管理

ATK2-SC1から変更なし．

6.4.2 割込みハンドラの先頭処理と末尾処理

ATK2-SC1から変更なし．

6.4.3 個別割込み禁止状態の管理

ATK2-SC1から変更なし．

6.5 タスクディスパッチャ

6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック

(6-5-1-4) OMIT_STKMPUINFOB（オプション）
(6-5-1-5) STKMPUINFOB（オプション）

MPU情報はターゲット依存なので，タスク初期化ブロック（TINIB）に入れたく
ない場合は，OMIT_STKMPUINFOBをマクロ定義し，TINIB中からSTKMPUINFOBを外
すことができる．

OMIT_STKMPUINFOBをマクロ定義すると，TINIB中にMPU設定情報が含まれなくな
るため，それに代わる情報は，ターゲット依存部で管理する必要がある．

また，OMIT_STKMPUINFOBを定義した場合，ジェネレータテンプレートファイル
から参照するtarget_def.csv（または，同等の役割を持つファイル）からTINIB
関連のSTKMPUINFOB生成情報を削除することをお勧め．削除しない場合は，
TINIB関連のSTKMPUINFOB情報定義は，無意味値となるため，使用してはいけな
い．

STKMPUINFOB管理する情報に関しては，「6.11.1 スタックのMPU設定情報ブロ
ック（STKMPUINFOB）」を参照．

(6-5-1-6) OMIT_OSAPMPUINFOB（オプション）
(6-5-1-7) OSAPMPUINFOB（オプション）

MPU情報はターゲット依存なので，OSアプリケーション初期化ブロック（OSAPINIB）
に入れたくない場合は，OMIT_OSAPMPUINFOBをマクロ定義し，OSAPINIB中から
OSAPMPUINFOBを外すことができる．

OMIT_OSAPMPUINFOBをマクロ定義すると，OSAPINIB中にMPU設定情報が含まれな
くなるため，それに代わる情報は，ターゲット依存部で管理する必要がある．

また，OMIT_OSAPMPUINFOBを定義した場合，ジェネレータテンプレートファイル
から参照するtarget_def.csv（または，同等の役割を持つファイル）から
OSAPINIB関連のOSAPMPUINFOB生成情報を削除する必要がある．

OSAPMPUINFOB管理する情報に関しては，「6.11.2 OSAP固有MPU設定情報ブロック
（OSAPMPUINFOB）」を参照．

6.5.2 ディスパッチャ本体

ディスパッチャ本体（dispatcher）は，ターゲット非依存部から直接呼び出さ
れることはなく，カーネルのターゲット依存部の内部からのみ呼び出される．
dispatcherは，タスクコンテキスト・OS割込み禁止状態・割込み優先度マスク
全解除状態から呼び出される．

dispatcherの処理内容は次の通り．

----------------------------------------
void
dispatcher(void)
{
#ifdef CFG_USE_STACKMONITORING
	スタックポインタ方式によるスタックモニタリング
	マジックナンバー方式によるスタックモニタリング
#endif /* CFG_USE_STACKMONITORING */

#ifdef CFG_USE_POSTTASKHOOK
	if (PostTaskHook != 0) {
		非タスクコンテキストに切り替える
		call_posttaskhook();
		コンテキストを戻す
	}
#endif /* CFG_USE_POSTTASKHOOK */

  dispatcher_0:
#ifdef LOG_DSP_ENTER
	log_dsp_enter(p_runtsk);
#endif /* LOG_DSP_ENTER */

	if (callevel_stat & TSYS_DISALLINT) {
		callevel_stat &= ~TSYS_DISALLINT;
		全割込み禁止を解除する
	}

  dispatcher_1:
	while ((p_runtsk = p_schedtsk) == NULL) {
		割込みを許可したらOS割込み禁止解除状態になるよう準備する
		非タスクコンテキストに切り換える
		OS割込み禁止を解除し，割込み発生を待つ … (*1)
		OS割込み禁止状態に戻す … (*2)
		タスクコンテキストに戻す
	}
	p_runosap = p_runtsk->p_osapinib … (*3)
	自タスク（p_runtsk）のTCBからスタックポインタを復帰する

	/* タスクディスパッチ時にMPU情報も切替える */
	if(タスクディスパッチする && p_runosapは非信頼OSアプリケーション){
		スタック情報のMPU設定           … (*4)
		if(p_runosapが切替えた){
			OSアプリケーション情報のMPU設定 … (*5)
		}
	}

#ifdef LOG_DSP_LEAVE
	log_dsp_leave(p_runtsk);
#endif /* LOG_DSP_LEAVE */

#ifdef CFG_USE_PRETASKHOOK
	if (PreTaskHook != 0) {
		非タスクコンテキストに切り替える
		call_pretaskhook();
		タスクコンテキストに戻す
	}
#endif /* CFG_USE_PRETASKHOOK */

	自タスクのTCBから実行再開番地を復帰し，そこへ分岐する
}
----------------------------------------

割込み発生を待つ間に非タスクコンテキストに切り換えるのは，この間に実行
される割込みハンドラ内で，タスクディスパッチをしないようにするためであ
る．この時，割込みハンドラが，非タスクコンテキスト用のスタックを使うよ
うにしなければならない．通常は，非タスクコンテキストに切り換える際に非
タスクコンテキスト用のスタックに切り換え，タスクコンテキストに戻す際に
元のスタックに切り換える．

ターゲットによっては（特に，シミュレーション環境の場合），強制的に非タ
スクコンテキストに切り換えることが難しい場合がある．その場合には，この
間に実行される割込みハンドラ内でタスクディスパッチをしないような仕組み
を実装することで，非タスクコンテキストへの切換えを省略することができる．

(*1)において，割込みを許可する処理と，割込み発生を待つ処理とは，不可分
に行なう必要がある．これを不可分に行なわない場合，割込みを許可した直後
に割込みが入り，その中でタスクが実行可能状態になると，実行すべきタスク
があるにもかかわらずプロセッサが割込み待ちになってしまう．

また，(*1)において，割込み発生を待つ命令が用意されていない場合や，それ
を発行するのが不都合な場合には，割込みをすべて許可して割込みを受け付け
られる状態になった後に，割込み発生を待たずに次に進んでもよい．この場合，
whileループによって，割込み発生を待つことになる．

OS割込み禁止を解除するための情報（例えば，OS割込み禁止前の割込み優先度
マスク）を変数に保持している場合には，(*2)でOS割込み禁止状態に戻す際に，
その変数の値も元に戻っている必要がある．特に，その変数が，割込み待ちの
間に実行した割込みハンドラ内で書き換えられる場合は，元の値に戻すことが
必要である．

割込み待ちの間は，p_runtskをNULL（＝0）に設定しなければならない（上の
処理内容をそのまま実装すればこうなる）．このように設定しないと，割込み
ハンドラからGetTaskIDを呼び出した際の動作が仕様に合致しなくなる．

(*3)のp_runosapは，（p_runtskに相当） 現在 RUNNING のタスクが所属するOS
アプリケーションを示すグローバル変数である．

メモリ保護機能において，ディスパッチする時に，(*4)(*5)では，MPUに情報を
設定する．また，(*5)のOSアプリケーション情報のMPU設定において，OSアプリ
ケーションのプライベート領域は，現在のOSアプリケーションと切替え先のOS
アプリケーションが同じである場合，情報が同じなので再設定しない．

タスクディスパッチによるタスク切り替え前に，CFG_USE_POSTTASKHOOK定義さ
れ，ユーザがポストタスクフックを定義した場合（PostTaskHook != NULL），
ポストタスクフック呼び出しインターフェース（call_posttaskhook）を呼出
す必要がある．
その一方，タスクディスパッチによるタスク切り替え後に，
CFG_USE_PRETASKHOOK定義され，ユーザがプレタスクフックを定義した場合
（PreTaskHook != NULL），プレタスクフック呼び出しインターフェース
（call_pretaskhook）を呼出す必要がある．
そこで，アセンブリ言語で記述されているディスパッチャ処理中にプレ/ポス
トタスクフックの呼び出しを埋め込む．標準的なプレ/ポストタスクフックが
C言語で記述されていると想定して，それを呼び出すようにコーディングする．

dispatcherをアセンブリ言語で記述する場合には，トレースログ取得処理は，
「6.2 トレースログ機能への対応」の節で記述した方法でコーディングするこ
と．なお，log_dsp_enterは切換え前のタスクのスタックで，log_dsp_leave 
は切換え後のタスクのスタックで実行する．

6.5.3 タスクコンテキストからのディスパッチ

ATK2-SC1から変更なし．

6.5.4 ディスパッチャの動作開始

ATK2-SC1から変更なし．

6.5.5 現在のコンテキストを捨ててディスパッチ

(6-5-5-2) void exit_and_dispatch_nohook(void)

現在のコンテキストを捨てて，ポストフック呼出さないディスパッチ
（exit_and_dispatch_nohook）は，自タスクを強制終了させる処理関数から呼
び出される．exit_and_dispatch_nohookは，リターンすることのない関数であ
る．

exit_and_dispatch_nohookは，タスクコンテキスト・OS割込み禁止状態・割込
み優先度マスク全解除状態で呼び出される．

exit_and_dispatch_nohookとexit_and_dispatchは，ポストタスクフック呼ぶ
かどうか以外，同じである（タスク強制終了なので，p_runtsk=NULLとして実
行）．

exit_and_dispatch_nohookの処理内容は次の通り．

----------------------------------------
void
exit_and_dispatch_nohook(void)
{
	dispatcher_0に分岐する
}
----------------------------------------

6.5.6 タスクの起動処理

(6-5-6-1) void activate_context(TCB *p_tcb)

タスクの起動処理（activate_context）は，タスクを休止状態から実行できる
状態にする時に呼ばれ，p_tcbで指定されたタスク（対象タスク）のTCB中のス
タックポインタをタスクのシステムスタックに初期化する．また，p_tcbが信
頼OSアプリケーションに所属する場合は，実行再開番地を信頼タスク開始時処
理（start_stask_r）に設定し，p_tcbが非信頼OSアプリケーションに所属する
場合は，実行再開番地を非信頼タスク開始時処理（start_utask_r）に設定す
る．この時点では，後述する理由で，対象タスクのスタック領域を使ってはな
らない．

対象タスクが最初に実行される時には，対象タスクを自タスクとして，実行再
開番地として登録したstart_utask_r（信頼タスクの場合はstart_stask_r）に
分岐してくる．start_utask_r（信頼タスクの場合はstart_stask_r）には，
dispatcherのみから分岐し，その時の状態は，タスクコンテキスト・OS割込み
禁止状態・割込み優先度マスク全解除状態である．

start_stask_rは，OS割込み禁止状態を解除した後，タスクの起動番地を呼び
出す．
さらに，タスクの起動番地から戻ってきた場合には，exit_taskを呼び出す．

start_utask_rは，OS割込み禁止状態を解除した後，CPUを非特権モードへ設定
する同時にタスクの起動番地を呼び出す．さらに，タスクの起動番地から戻っ
てきた場合には，exit_utaskを呼び出す．

activate_contextとstart_rの処理内容は次の通り．

----------------------------------------
void
activate_context(TCB *p_tcb)
{
	指定されたタスク（p_tcb）のTCB中のスタックポインタを初期化する
	if (指定されたタスクが非信頼タスク) {
		start_utask_rを，実行再開番地として自タスクのTCBに保存する … (*a)
	}
	else {
		start_stask_rを，実行再開番地として自タスクのTCBに保存する … (*a)
	}
	return;

  start_stask_r:
	呼出し関数をexit_taskとして設定する  … (*c)
	特権モードで動作するよう準備
	start_rに分岐する

  start_utask_r:
	呼出し関数をexit_utaskとして設定する  … (*c)
	非特権モードで動作するよう準備
	スタックをシステムスタックからユーザスタックに切り替える
	start_rに分岐する

  start_r:
#ifdef CFG_USE_STACKMONITORING
	タスク起動毎にタスクのシステムスタックのマジックナンバーを初期化する … (*d)
#endif /* CFG_USE_STACKMONITORING */
    p_runtsk->curpri = p_runtsk->p_tinib->exepri;
	自タスクの起動番地へ分岐するように準備する
	OS割込み禁止解除状態にする
	動作モード設定する同時に，
			自タスク（p_runtsk）の起動番地を呼び出す … (*e)
}
----------------------------------------

(*c)で自タスクの起動番地を呼び出す時の返り番地をexit_utask(信頼タスク
の場合exit_task)の番地としておき，タスクが不正終了した場合，保護処理を
行う．

ここで，タスクの起動処理において対象タスクのスタック領域を使ってはなら
ない理由は，次の通り．複数の基本タスクがスタック領域を共有している場合
に，タスクの起動時点では，そのタスクとスタック領域を共有しているタスク
が，スタック領域を使用している可能性があるためである．

このポーティングガイドでは，タスクの実行再開番地をTCBに保存している
(*a)．これをスタックに保存する方法も考えられるが，タスクの起動処理でス
タック領域が使えないことから，タスクの起動処理だけは例外扱いしなければ
ならない．例えば，タスクの起動処理においてはTCB中のスタックポインタを
特殊な値（例えば0）に設定しておき，ディスパッチャ本体でTCB中のスタック
ポインタがその値の場合にはstart_utask_r（信頼の場合は，start_stask_r）
に分岐させ，start_utask_r（信頼の場合は，start_stask_r）においてスタッ
クポインタを初期化する方法が考えられる．

(*d)において，SC3ではタスク強制終了があるので，タスク起動毎にマジック
ナンバーを初期化する．

(*e)において，CPU動作モードとタスクの呼出しは，同時に行う必要がある．
start_utask_r（信頼の場合は，start_stask_r）は，特権モードで呼出される
が，信頼OSアプリケーションに所属するタスクの場合，特権モードで，非信頼
OSアプリケーションに所属するタスクは，非特権モードで実行する必要がある
．例外/割込みからのリターン命令を使用するのが1つの方法である．

6.6 割込みハンドラ

6.6.1 割込みハンドラの出入口処理

C2ISRの割込みの出入口処理の方法は，プロセッサによって大きく異なるが，
ATK2-SC3においては，おおよその処理内容は次の通り．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	if (非特権モードで割込み発生) {
		スタックを実行状態のタスクのシステムスタックに切り換える
	}
	少なくともOS割込みを禁止した状態にする … (*f)
	スクラッチレジスタをスタックに保存する
	if (タスクコンテキストで割込み発生) {
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}
	割込み優先度マスクを，受け付けた割込み要求の割込優先度に設定し，
				OS割込み禁止解除状態にする（受け付けた割込みよりも
				優先度の高い割込みを受け付けるようにする）… (*i)

#ifdef CFG_USE_STACKMONITORING
	if (タスクコンテキストで割込み発生) {
		スタックポインタチェック方式でタスクシステムスタックの
											スタックモニタリングを行う
		マジックナンバーチェック方式でタスクシステムスタックの
											スタックモニタリングを行う
	}
	else {
		スタック残量チェック方式でC2ISR用スタックのスタックモニタ
		リングを行う
		マジックナンバーチェック方式でC2ISR用スタックのスタックモニタ
		リングを行う
	}
#endif /* CFG_USE_STACKMONITORING */

	callevel_statを保存
	callevel_statに割込みビットを立てる
	run_trustedを保存
	p_runosapを保存
	p_runisrを保存
	p_runisrを実行するC2ISRに対応するisrcb_tableの要素に設定する
	p_runosapを実行するC2ISRが所属するOSアプリケーションに設定する

	C2ISRを呼び出す

#ifdef CFG_USE_STACKMONITORING
	マジックナンバーチェック方式でC2ISR用スタックのスタックモニタリン
	グを行う
#endif /* CFG_USE_STACKMONITORING */

	exit_isr2();			/* C2ISRの不正終了チェック */

	p_runisrを復帰
	p_runosapを復帰
	run_trustedを復帰
	callevel_statを復帰

  ret_int:
	if (タスクコンテキストで割込み発生) {
		（少なくとも）OS割込みを禁止した状態にする
		スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
		スタックポインタを復帰
		if (p_runtsk == NULL) {
			OS割込み禁止状態にする … (*e)
			割込み優先度マスクを，全解除状態（TIPM_ENAALL）に設定する
								 … (*h)
			dispatcherに分岐する
		}
		else if (p_runtsk != p_schedtsk) {
			OS割込み禁止状態にする							… (*e)
			割込み優先度マスクを，全解除状態（TIPM_ENAALL）に設定する
															… (*h)
			スクラッチレジスタを除くすべてのレジスタをスタックに保存す
			る
			スタックポインタを自タスク（p_runtsk）のTCBに保存する
			ret_int_rを，実行再開番地として自タスクのTCBに保存する

			dispatcherに分岐する

		  ret_int_r:
			スクラッチレジスタを除くすべてのレジスタをスタックから復帰
			する
		}
	}
	割込み処理からのリターン後に，割込み優先度マスクが
								割込み処理前の値に戻るように準備する
	割込み処理からのリターン後に，OS割込み禁止解除状態に戻るように準備
	する
	スクラッチレジスタをスタックから復帰する
	割込み処理からのリターン
}
----------------------------------------

6.6.2 割込み要求ラインの属性の設定

ATK2-SC1から変更なし．

6.6.3 割込み管理機能の初期化処理の変更

(6-6-3-9) intatr：割込み属性

6.6.4 デフォルトのC2ISR

ATK2-SC1から変更なし．

6.6.5 カーネル管理外の割込み

ATK2-SC1から変更なし．

6.6.6 DisableAllInterrupts/EnableAllInterruptsの処理内容の変更

ATK2-SC1から変更なし．

6.6.7 割込み禁止解除

(6-6-7-1) LOCAL_INLINE void x_clear_nested_os_int(void)

6.7 スタックモニタリング

SC3でもスタックモニタリング機能を実装する．非信頼タスクのユーザスタッ
クスタックは，メモリ保護ユニット（MPU）より保護されるが，以下のスタッ
クをスタックモニタリング機能で保護する．
(1)非信頼タスクのシステムスタック
(2)信頼タスクのシステムスタック
(3)システムスタック
(4)信頼関数実行時のスタック

6.7.1 ディスパッチャとC2ISRの出入口処理でのスタックモニタリング

ディスパッチャとC2ISRの出入口処理でのスタックモニタリングでスタックオ
ーバーフローが検出された場合の処理は以下の通り．ATK2-SC3ではスタックオ
ーバーフロー検出時のcall_protectionhook_mainからはリターンする可能性が
ある．

----------------------------------------
#ifdef CFG_USE_STACKMONITORING
void
スタックオーバーフロー検出処理(void)
{
	uint32 ret;

	if (C2ISRの出入口処理でのスタックモニタリング) {
		OS割込み禁止状態にする
		ret = E_OS_STACKFAULT;
	}
	if (タスクコンテキスト) {
		非タスクコンテキストに切り替える
		ret = E_OS_STACKFAULT;
	}
	pre_protection_supervised = TRUE;
	call_protectionhook_main(ret);
	/* ここには戻ってこない */
}
#endif /* CFG_USE_STACKMONITORING */
----------------------------------------

6.7.2 信頼関数実行の出口処理でのスタックモニタリング

一方，信頼関数実行の出口処理でのスタックモニタリングでスタックオーバー
フローが検出された場合の処理は以下の通り．ATK2-SC3ではスタックオーバー
フロー検出時のcall_protectionhook_mainからはリターンしない．

----------------------------------------
StatusType
CallTrustedFunction(...)
{
	...

	信頼関数実行

#ifdef CFG_USE_STACKMONITORING
	if (C2ISR処理レベル) {
		if (システムスタックマジックナンバーチェックNG) {
			OS割込み禁止状態にする
			pre_protection_supervised = TRUE;
			call_protectionhk_main(E_OS_STACKFAULT);
			/* ここには戻ってこない */
		}
	}
	else {
		if (実行中タスクシステムスタックマジックナンバーチェックNG) {
			OS割込み禁止状態にする
			pre_protection_supervised = TRUE;
			call_protectionhk_main(E_OS_STACKFAULT);
			/* ここには戻ってこない */
		}
	}
#endif /* CFG_USE_STACKMONITORING */

	...
}
----------------------------------------

信頼関数実行前に，信頼関数使用するスタックの量と，使用するスタックの空
き量を照合している．

信頼関数実行後使用したスタックに対してマジックナンバー方式のみ，チェッ
クしている理由は，チェックする時点で，スタックポインタは，信頼関数実行
する前の状態に戻ったことである．


6.8 CPU例外ハンドラ

CPU例外の出入口処理の方法はプロセッサによって大きく異なるが，おおよそ
の処理内容は次の通り．

----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	if (非特権モードで発生 && フック処理中で発生) {
		if (CPU例外発生が未ネスト && C1ISR処理中以外でCPU例外発生) {
			スタックを非タスクコンテキスト用のスタックに切り換え準備
		}
	}

	スクラッチレジスタ及びスタックポインタを非タスクコンテキストスタッ
	クに保存する

	if (OS割込み禁止状態でない &&
		C1ISR実行中のCPU例外でない && 全割込み禁止状態でない){
		OS割込み禁止状態にする
	}

	ターゲット依存のCPU例外情報を取得する                   … (*h)

	if (全割込み禁止解除状態でCPU例外発生) {
		全割込み禁止状態を解除する                          … (*i)
	}

	ターゲット依存のCPU例外情報を退避する                   … (*j)
	ターゲット依存のCPU例外情報を保存する

	if (例外要因番号 > TNUM_EXCH) {
		エラーコード = E_OS_PROTECTION_EXCEPTIONとする
	}
	else {
		例外コード変換テーブルからエラーコードを取得する
	}

	if (例外発生時が非特権モード) {
		pre_protection_supervised = FALSE;
	}
	else {
		pre_protection_supervised = TRUE;
	}

	call_protectionhook_main(エラーコード);

	ターゲット依存のCPU例外情報を復帰する

  ret_exc:
	割込み・例外のネスト回数（except_nest_cnt）をディクリメントする

	CPU例外処理からのリターン後に，CPU例外発生前の割込み禁止状態に戻る
	ように準備する                                          … (*k)

	CPU例外処理中に変更した全割込み状態をリターン後にも反映
	するため，準備する                                      … (*l)

	全割込み禁止状態にする

  ret_int_1:
	スクラッチレジスタをスタックから復帰する
	退避したスタックポインタを復帰する
	CPU例外処理からのリターン
}
----------------------------------------

全割込み禁止状態でCPU例外が発生した場合は，全割込み禁止状態でプロテク
ションフックを呼び出す．

割込み応答性向上するには，全割込み禁止している状態の処理をなるべく少な
くする必要があるので，例外発生要因情報の保存は，(*h)ではなく，(*i)処理
の後にすべきである．上記の例では，(*j)で保存している．

プロテクションフックを実行する際に経由する部分では，CPU例外が起こる可
能性を極力減らすとともに，CPU例外を起こす可能性がある場合（例えば，ス
クラッチレジスタをスタックに保存する時に，バスエラーなどのCPU例外が発
生する可能性が考えられる）には，その可能性をターゲット依存部のユーザー
ズマニュアルに記載しなければならない．

ret_exc以降の処理は，割込みの出入口処理のret_int以降の処理とほぼ同じで
あるため，ターゲットによっては，共通のルーチンを用いることができる可能
性がある．

CPU例外処理中に，全割込み禁止した場合，CPU例外戻った側に反映しなければ
ならないので，(*l)で変更した全割込み状態をリターン後にも反映するため，
工夫する．

6.9 ソフトウェア割込みハンドラ

ソフトウェア割込みハンドラは，SC3よりシステムサービスのエントリルーチ
ンとして機能する．
ソフトウェア割込みハンドラには，システムサービスの機能コード，システム
サービスのパラメータを入力値として，渡す．システムサービス実行の戻り値
を呼出し側に返す．

ソフトウェア割込み本体は，以下の処理を行う．
(a) 呼出し元のコンテキストの保存（リターン時の復帰に使用）

(b) スタックの切替え（ユーザスタックからシステムスタックへ切替え）
呼出元が特権モードの場合は切替えない（すでにシステムスタックか割込みス
タックを使用しているため切替え不要）．

(c) カーネルサービスの特定
呼出し元から渡されたシステムサービスの機能コードを利用して，システムサ
ービスの先頭アドレスを特定する．

(d)システムサービス本体の呼出し
上記(c)より取得したシステムサービスを呼出し， システムサービスの戻り値
を呼出し元に返す準備を行う．

(e) ソフトウェア割込みルーチンの終了処理
上記(a)で保存した呼出し元のコンテキストを復帰し，呼出し元へリターンす
る．

ソフトウェア割込みによるシステムサービス呼出しのおおよその処理内容は次
の通り．

----------------------------------------
uint32
trap_handler(FunctionCodeType fncd, システムサービスパラメータリスト)
{
	uint32		retval;

	if (非特権モードからの呼び出し) {
		if (非信頼フック実行中からの呼び出し) {
			スタックを非信頼フック実行前のスタックに切換える  … (*a)
		}
		else {
			スタックを実行状態のタスクのシステムスタックに切換える
		}
	}
	呼出し元コンテキストの保存

	if (fncd > TMAX_SVCID) {
		/*
		 *  システムサービス不正呼出しの場合
		 */
		no_support_service();
	}
	else {
		カーネルサービスの先頭アドレスの特定（svc_table[fncd]）
		ソフトウェア割込みによりシステム状態が変化する場合には，
					ソフトウェア割込み前のシステム状態に戻す … (*b)
		システムサービス実行後の戻り番地（trp_SVC_ret）指定
		システムサービスの実行：
		retval = (*(svc_table[fncd]))(システムサービスパラメータリスト);
	}


  trp_SVC_ret:
	ソフトウェア割込みからリターン後のシステム状態が，
					この時点でのシステム状態になるよう準備する … (*c)
	全割込み禁止状態にする

	/* 性能測定用 キャッシュパージ処理 */
#ifdef PERF_TEST
	if (キャッシュパージフラグ != 0) {
		命令キャッシュ領域クリア
	}
#endif /* PERF_TEST */

	呼出し元コンテキストの復帰
	return(retval);
}
----------------------------------------

(*a)において，非信頼のフックルーチン実行中は，スタックポインタ保持変数
（hook_savedsp）が非信頼のフックルーチンを実行前のスタックになっている
ので，その続きからスタックを使う．

(*b)において，ソフトウェア割込みより，システム状態が変化した場合，ソフ
トウェア発生前の状態に戻して，システムサービスを呼出す．要は，システム
サービスは，ソフトウェア割込み使用かどうかに関わらずシステム呼出し時点
の状態で実行する．

(*c)において，システムサービス処理中に，変更したシステム状態(例えば，
全割込み禁止など）は，ソフトウェア割込みリターン後にも反映する．

svc_tableは，システムサービステーブルと呼び，ソフトウェア割込みによる
実行したいシステムサービスの先頭アドレスが登録される．ソフトウェア割込
みによるシステムサービス指定する場合は，システムサービスコードを用い
る．

no_support_service()関数は，不正な機能コードを指定して，システムサービ
ス発行時の処理であり，エラーコードにE_OS_SERVICEIDを設定し，サービスID
にOSServiceId_INVALIDを設定して，エラーフックを呼出す．

6.10 信頼OSAPと非信頼OSAPからのシステムサービス呼出し

SC3のメモリ保護機能を実現するため，プロセッサは少なくとも特権モードと
非特権モードをサポートする必要がある．カーネル及び信頼OSアプリケーショ
ンに所属する処理単位は特権モードで実行し，メモリ保護機構（MPU）が働か
ない（※1）．非信頼OSアプリケーションに所属する処理単位は非特権モード
で実行し，メモリ保護機構（MPU）が働く．また，プロセッサは，ソフトウェ
ア割込みなど非特権モードから特権モードへ遷移できる機能（命令）を有する．

信頼OSアプリケーションは，システムサービスを直接関数呼び出しできるが，
非信頼OSアプリケーションから，システムサービスを呼出すため，ソフトウェ
ア割込みによる呼出し機能をターゲット依存部でカーネルのサービスコールの
インタフェースを実装する．

6.10.1 システムサービス呼出しの定義

(1) システムサービスの関数呼出しの定義(svc_funcall.h)：

----------------------------------------
#define SVC_CALL(system_service) _kernel_ ## system_service

#ifdef TOPPERS_SVC_FUNCCALL
#define StartOS _kernel_StartOS
#define ActivateTask _kernel_ActivateTask
...
#endif
----------------------------------------

(2) システムサービスのソフトウェア割込み呼出しの定義(tool_svc.h)：

----------------------------------------
#define SVC_TRAP(system_service) _trap_ ## system_service

#ifndef TOPPERS_SVC_FUNCCALL
#define StartOS _trap_StartOS
#define ActivateTask _trap_ActivateTask
...
#endif

void
_trap_StartOS(AppModeType Mode)
{
	CAL_SVC_1N(void, TFN_STARTOS, AppModeType, Mode);
}

StatusType
_trap_ActivateTask(TaskType TaskID)
{
	CAL_SVC_1M(StatusType, TFN_ACTIVATETASK, TaskType, TaskID);
}
----------------------------------------

DisableAllInterruptsに関しては，非信頼OSAPから呼び出せない仕様である．
よって，オーバヘッド短縮も兼ねて，システムサービスを直接呼び出すように実装する．
----------------------------------------
#define DisableAllInterrupts		_kernel_DisableAllInterrupts
----------------------------------------

TFN_STARTOSなどは，呼び出したいシステムサービスコードであり，システム
サービステーブル(svc_table)に登録したシステムサービスの添字である．

(3) ソフトウェア割込み(例：trap)によるシステムサービス呼出し定義
    (prc_svc.h)：

----------------------------------------
#define CAL_SVC_1N(TYPE, FNCD, TYPE1, PAR1)						\
	register FunctionCodeType input_fncd_r	= (FNCD);			\
	register TYPE1 input_param_r			= (TYPE1) (PAR1);	\
	register FunctionCodeType output_r;							\
	Asm (														\
		"trap \n\t"												\
		: input_fncd_r, input_param_r							\
		: output_r												\
		:  "...", "memory"										\
		);														\
----------------------------------------

----------------------------------------
#define CAL_SVC_1M(TYPE, FNCD, TYPE1, PAR1)						\
	register FunctionCodeType input_fncd_r	= (FNCD);			\
	register TYPE1 input_param_r			= (TYPE1) (PAR1);	\
	register FunctionCodeType ret_r;							\
	register FunctionCodeType output_r;							\
	Asm (														\
		"trap \n\t"												\
		: input_fncd_r, input_param_r							\
		: ret_r, output_r										\
		:  "...","memory"										\
		);														\
	return ((TYPE) output_r);
----------------------------------------

※GCCの拡張アセンブリ構文：
 asm(アセンブリテンプレート
     : 出力オペランド
     : 入力オペランド
     : 破壊されるレジスタのリスト
    )

上記マクロ関数定義時，以下のルールを従う．
マクロ名は，CAL_SVC_nxとし，nxは，意味を持つ．
n：パラメータ数
	範囲：0〜3（システムサービスのパラメータ数）
	※ターゲット定義のシステムサービス追加した場合，その最大数に合わせ
	る
x：戻り値
	範囲：N（戻り値なし），M（戻り値あり）

6.10.2 信頼OSAPからのシステムサービス呼出し

基本的にシステムサービスの呼出しは，ソフトウェア割込み経由で呼出しが基
本であるが，システムサービス呼出しのオーバヘッドを削減するため，信頼OS
アプリケーションに所属する処理単位からシステムサービスを呼出す場合，シ
ステムサービスの呼出しは，(直接)関数呼出しも出来る．

関数呼出しを指定するため，関数呼出しをしたいソースの先頭に，以下のマク
ロを定義するか，SVC_CALL(system_service)より明示的に関数呼び出しのシス
テムサービス実行をするかが出来る．

(6.10.2.1) TOPPERS_SVC_FUNCCALL

このマクロをソース先頭定義することで，ソースファイル内のシステムサービ
スの呼出しは，_kernel_<system_service>に置換われ，関数呼出しとなる．

6.10.3 非信頼OSAPからのシステムサービス呼出し

ソースの先頭に，TOPPERS_SVC_FUNCCALLマクロを定義していない場合，システ
ムサービスの実行は，ソフトウェア割込みよるシステムサービス実行となる．
また，SVC_TRAP(system_service)より明示的にソフトウェア割込みによるシス
テムサービス実行も出来る．

6.10.4 ターゲット依存システムサービスの追加

ターゲット依存のシステムサービスを追加したい場合，ターゲット依存システ
ムサービステーブルテーブルは，以下のマクロを用いて定義する．

(6.10.4.1) PRC_SVC_TABLE
(6.10.4.2) PRC_SVC_NUM

ターゲット依存で，追加したいシステムサービスの先頭アドレスを
PRC_SVC_TABLEマクロの定義に追加し，システムサービス定義の数を
PRC_SVC_NUMマクロに定義することで，システムサービステーブル(svc_table)
に反映される．

(6.10.4.3) OTHER_PRC_SVC_TABLE

ターゲット依存で，追加したいシステムサービス関連マクロ（PRC_SVC_TABLE
とPRC_SVC_NUM）は，別のヘッダファイル(*.h)に定義されている場合，上記マ
クロOTHER_PRC_SVC_TABLEをインクルードファイル名に定義することが出来る．

例：#define OTHER_PRC_SVC_TABLE target_svc_table_test.hを定義すること
で，prc_config.hに#include "target_svc_table_test.h"として展開され，
target_svc_table_test.hファイル定義しているPRC_SVC_TABLEとPRC_SVC_NUM
が有効となる．

上記ソフトウェア割込みによるシステムサービス呼び出し関係のファイルの生
成は，utils/gensvc_atk（サービスコールインタフェース生成プログラム）に
よる自動生成が出来る．

6.11 メモリ保護機構（MPU）制御

6.11.1 スタックのMPU設定情報ブロック（STKMPUINFOB）

MPUによるスタック領域保護するため，MPUに設定する情報を保持するブロック
をターゲット依存部に定義する．MPU設定情報は，ターゲット依存であるが，
保持する情報は，以下である．

(6.11.1.1) 領域の先頭番地
(6.11.1.2) 領域の終端番地(若しくは領域のサイズ)

6.11.2 OSAP固有MPU設定情報ブロック（OSAPMPUINFOB）

MPUによるOSAP固有領域保護するため，MPUに設定する情報を保持するブロック
をターゲット依存部に定義する．MPU設定情報は，ターゲット依存であるが，
保持する情報は，以下である．

(6.11.2.1) 領域の先頭番地（複数の命令領域・データ領域）
(6.11.2.2) 領域の終端番地（複数の命令領域・データ領域）
(6.11.2.3) アクセスパターン（読み・書き・実行）（複数の命令領域・デー
           タ領域）
(6.11.2.4) 命令領域数
(6.11.2.5) データ領域数

6.11.3 MPU初期化処理

MPU機能を有効するため，MPUの初期化を行う処理は，以下の通りである．

----------------------------------------
void
prc_init_mpu(void)
{
	
	現在MPUに設定している情報の管理変数の初期化

	/* MPU初期情報を設定するため */
	MPU機能を無効にする
	
	/*  全命令・データMPUの0サイズ領域全アクセス権なしで初期化
	 *  必要の場合，バックグラウンド領域MPU設定
	 *  共有領域のMPU設定
	 */
	MPU初期情報を設定する

	MPU機能を有効にする
}
----------------------------------------


6.11.4 OSAP固有MPU情報設定処理

各OSAP固有MPU情報をMPUに設定する機能は，以下の通りである．

----------------------------------------
void
prc_set_osap_mpu(const OSAPINIB *p_osapinib)
{
	
	if (既に設定中のOSAP != 設定するOSAP) {
		既に設定中のOSAP = 設定するOSAP;

		設定するOSAPのMPU情報を取得して，MPUに設定する … (*a)
	}
}
----------------------------------------

(*a)では，OSAP固有に命令領域とデータ領域は，複数存在する場合，全ての命
令領域・データ領域に対して，アクセス権限を設定する．

6.11.5 MPU依存のバックグラウンド領域チェック

先頭番地及び終端番地により，引数で指定される領域は，命令バックグラウン
ド領域に入っている場合，AP_Executable権あり，データバックグラウンド領
域に入っている場合，AP_Writable | AP_Readable権あり，それ以外の場合，
NO_ACCESS権を返す．

----------------------------------------
AccessType
probe_trusted_osap_mem(const MemoryStartAddressType sadr, 
		   const MemoryStartAddressType eadr)
{
	AccessType ret;

	ret |= (領域[sadr1,eadr1] ⊆ 命令バックグラウンド領域)? 
			AP_Executable : NO_ACCESS;                     … (*a)
	ret |= (領域[sadr1,eadr1] ⊆ データバックグラウンド領域) ? 
			(AP_Writable | AP_Readable) : NO_ACCESS;       … (*b)

	return(ret);
}
----------------------------------------

(*a)(*b)また，特権モード実行時，MPUの機能停止する設計において，バック
グラウンド領域持たないため，AP_Executable | AP_Writable | AP_Readable
のように全てのアクセス権ありで返しても良い．

6.11.6 OSが生成したリスタートタスクに対するMPU設定
OSが生成したリスタートタスクのMPU設定は信頼タスクと同じとなるようターゲット依存部で設定する．
対象のタスクがOSが生成したリスタートタスクかどうかは以下の変数を用いて判断する．
tmin_os_restarttask ・・・ OSが生成したリスタートタスクのうち，最小のIDを指す
tskidの並びは(ユーザがコンフィギュレーションしたタスク) < (OSが生成したリスタートタスク)となっているので，tmin_os_restarttask <= tskid がTRUEであるとき，OSが生成したリスタートタスクである．

6.12 メモリ管理のチューニング

6.12.1 メモリオブジェクトの管理

(6.12.1.1） OMIT_STANDARD_MEMINIB（オプション）

ターゲット非依存部に含まれる標準のメモリオブジェクト管理機能を用いない
場合や，メモリオブジェクト管理機能の構造体，変数，関数をターゲット依存
部で用意し，標準のメモリオブジェクト管理と同等の情報をターゲット依存の
データ構造で管理する場合には，このシンボルをマクロ定義する．

このシンボルをマクロ定義する場合，ターゲット依存部にメモリアクセスチェ
ック用関数（check_osap_memory），C2ISRメモリアクセスチェック関数
（check_isr_memory），タスクメモリアクセスチェック（check_task_memory）
を用意する必要がある．

check_osap_memory関数は，引数で指定したOSアプリケーションに対して，引
数で指定するメモリ領域のアクセス権のチェックを行う．信頼OSアプリケーシ
ョンの場合は，バックグラウンドをチェックする（現実装では全領域アクセス
可能）．非信頼OSアプリケーションの場合は，メモリオブジェクトのアクセス
属性（リード，ライト，実行）を返却する．

check_isr_memory関数は，引数で指定した割込みにおいて，引数で指定したメ
モリ開始アドレスとサイズのメモリ領域に対して，アクセス属性（リード，ラ
イト，実行，スタック）を返す．また，引数で指定したメモリ領域は，メモリ
オブジェクトを跨いだ場合，その情報を引数より返す必要がある．

check_task_memory関数は，引数で指定したタスクにおいて，引数で指定したメ
モリ開始アドレスとサイズのメモリ領域に対して，アクセス属性（リード，ラ
イト，実行，スタック）を返す．また，引数で指定したメモリ領域は，メモリ
オブジェクトを跨いだ場合，その情報を引数より返す必要がある．

----------------------------------------

AccessType
check_osap_memory(const OSAPINIB *p_osapinib, 
                  const MemoryStartAddressType adr,
                  MemorySizeType size)
{
	AccessType ret;
	
	if (p_osapinib == 信頼OSアプリケーション) {
		ret |= (領域[adr,adr + size] ⊆ バックグラウンド領域)? 
				(AP_Executable | AP_Writable | AP_Readable) :
				 NO_ACCESS;
	}
	else {
		ret |= (領域[adr,adr + size] メモリオブジェクト跨ぐ)? 
				(NO_ACCESS, *over_region = true)：
				(領域[adr,adr + size]のアクセス権) ;
	}
	return (ret);
}

AccessType
check_isr_memory(ISRCB *p_isrcb, const MemoryStartAddressType adr,
				 MemorySizeType size, boolean *over_region)
{
	AccessType ret;

	*over_region = false;
	if (領域[adr,adr + size] メモリオブジェクト跨ぐ) {
		*over_region = true;
	}
	else {
		ret = (領域[adr,adr + size]  ⊆ 割込みスタック領域)? 
				(AP_Readable | AP_Writable | AP_StackSpace)：
				NO_ACCESS;
	}

	/* FL2では割込みは信頼OSアプリケーションにしか属さない */
	ret |= AP_Readable | AP_Writable | AP_Executable;

	return (ret);
}

AccessType
check_task_memory(const TCB *p_tcb, const MemoryStartAddressType adr,
					MemorySizeType size, boolean *over_region)
{
	AccessType ret;

	*over_region = false;
	if (領域[adr,adr + size] メモリオブジェクト跨ぐ) {
		*over_region = true;
	}

	if (p_tcbは信頼OSアプリケーションに所属) {
		ret = (領域[adr,adr + size]  ⊆ タスクシステムスタック領域)? 
				(AP_Readable | AP_Writable | AP_StackSpace)：
				NO_ACCESS;

		/* 信頼タスクの場合は全アクセス可能 */
		ret |= (AP_Readable | AP_Writable | AP_Executable);
	}
	else if (*over_region == false) {
		ret = (領域[adr,adr + size] ⊆ タスクユーザスタック領域)? 
				(AP_Writable | AP_Readable | AP_StackSpace)： 
				(領域[adr,adr + size]のアクセス権);
	}

	return (ret);
}

----------------------------------------

6.12.2 メモリアクセス権チェックのためのマクロ

カーネル内標準で，実行中OSアプリケーションに対して，引数で指定した変
数アドレスと変数タイプのアクセス（リード，ライド）権限のチェックマク
ロが用意されている．メモリオブジェクトの依存部管理などにより，依存部
でPROBE_MEM_WRITEとPROBE_MEM_RWを定義することで，標準のチェックマクロ
を無効にすることができる．

(6.12.2.1） PROBE_MEM_WRITE（オプション）
(6.12.2.2） PROBE_MEM_RW（オプション）

----------------------------------------

#define PROBE_MEM_WRITE(p_var, type) \
	 (領域[p_var,adr + sizeof(type)] & AP_Writable)

#define PROBE_MEM_RW(p_var, type) \
	 (領域[p_var,adr + sizeof(type)] & (AP_Readable | AP_Writable))

----------------------------------------


6.13 エラーフック，シャットダウンフック呼び出し

節番号以外，ATK2-SC1から変更なし．

6.14 カーネルの起動・終了とスタック領域など

(6-14-1) スタートアップモジュール

(c) void initialize_sections(void)でbssセクションとdataセクションの初
    期化

各dataセクションに初期値を設定し，各bssセクションをクリアする．

まず，初期値ありデータセクションの初期化(dataセクション)の初期化を行
う．初期値ありデータセクションを初期化する時に，dataセクション初期化テ
ーブルにある初期化データ領域の先頭番地から，dataセクションに値を取得し
て，セットする．dataセクション初期化テーブルは，dataセクションの初期化
に依存してはいけないので，コンフィギュレーションのメモリ配置時に，読み
専用データ領域（rodataセクション）に配置すればよい．

dataセクション初期化後に，bssセクションを初期化すれば，bssセクション初
期化ブロックは，する時，dataセクションは，読み専用データ領域に配置する
必要がない．

また，OMIT_INITIALIZE_SECTIONSマクロを定義することで，非依存部定義した
bssセクションとdataセクションの初期化処理を無効化して，
initialize_sectionsを依存部で実装することができる．

カーネル本体は，kerflgがfalse（＝0）に初期化される以外に，bssセクショ
ンが初期化されることに依存していないため，initialize_sectionsを依存部
で用意する場合，bssセクション初期化分のシステムの起動時間を短縮するた
めに，kerflgをfalseに初期化するだけで十分である．

6.15 カーネル内部のチューニング

6.15.1 ビットマップサーチ

節番号以外，ATK2-SC1から変更なし．

6.16 カーネル実装に関するその他の定義

6.16.1 エラーチェック方法の指定

節番号以外，ATK2-SC1から変更なし．

6.16.2 非タスクコンテキスト用のスタック領域

節番号以外，ATK2-SC1から変更なし．

6.16.3 空ラベルの定義

節番号以外，ATK2-SC1から変更なし．

6.16.4 各スタックのデフォルト値

(6-16-4-3) DEFAULT_TASKSYSTEMSTKSZ（オプション）
(6-16-4-4) DEFAULT_ISRSYSTEMSTKSZ（オプション）
(6-16-4-5) DEFAULT_HOOKSTKSZ（オプション）
(6-16-4-6) DEFAULT_NONTRUSTEDHOOKSTKSZ（オプション）
(6-16-4-7) DEFAULT_TRUSTEDFUNCTIONSTKSZ（オプション）
(6-16-4-8) DEFAULT_OSSTKSZ（オプション）

6.16.5 スタックマジックナンバー領域操作マクロの定義

(6-16-5-2) TOPPERS_SSTK_MAGIC_REGION（オプション）

スタックモニタリングで使用するタスクシステムスタック用マジックナンバー
の格納位置を返すマクロであり，スタックの成長方向がアドレスの大きい方か
ら小さい方へ成長することをデフォルト実装としている．スタック成長方向に
よりターゲットで再定義することができる．p_tinibで指定ししたタスク初期
化ブロックを基づいて，スタック成長方向によりターゲットで再定義すること
ができる．

6.16.6 標準以外メモリリージョン属性の定義

ハードウェアにどのような性質のメモリリージョンが存在するかは，ターゲッ
トに依存するので，標準ROM，標準RAM以外のメモリリージョンが存在する場合，
ターゲット依存部で，属性を識別するため以下のマクロを定義する．

(6-16-6-1)TARGET_REGATR

ただし，非依存部で以下の定義値は，既にビット単位で予約されているので，
定義値を注意する．
    0x00    /* オブジェクト属性を指定しない */
    0x01    /* 書込みアクセス禁止 */
    0x02    /* 標準ROMリージョン */
    0x04    /* 標準RAMリージョン */

コンフィギュレーション時，非依存部のでTARGET_REGATRを用いて，定義した
メモリリージョンの有効性をチェックしている．

6.17 トレースログ機能に関する設定

6.17.1 取得できるトレースログの種類とマクロ

節番号以外，ATK2-SC1から変更なし．

6.17.2 トレースログ記録のサンプルコード

節番号以外，ATK2-SC1から変更なし．

6.18 フック，シャットダウンフックの強制終了

Release 1.4.0以降では必要ない．

6.19 コア起動

(6-19-1) LOCAL_INLINE boolean x_start_core(CoreIdType coreid)

指定されたコアの起動処理を行う．

----------------------------------------
LOCAL_INLINE boolean x_start_core(CoreIdType coreid)
{
	if (指定されたコアID＜サポートしているコア数) {
		(SYSVER_REG5 + 4 * coreid )に，MAGIC_STARTを書き込む
		TRUEを返す
	} else {
		FALSEを返す
	}
	返り値をリターン
}
----------------------------------------

(6-19-2) LOCAL_INLINE boolean is_halt(CoreIdType coreid)

指定されたコアが起動されたかの確認を行う．

----------------------------------------
LOCAL_INLINE boolean is_halt(CoreIdType coreid)
{
	if (SYSVER_REG5 + 4 * coreid )にMAGIC_STARTが書き込まれていない {
		TRUEを返す
	} else {
		FALSEを返す
	}
}
----------------------------------------

6.20 フックの確認

Release 1.4.0以降では必要ない．

6.21 スタック切り替え

call_protectionhk_main_stkchg (ercd)

フック用スタックへの切り替えを実施した上でフックルーチンの実行を行う．

6.22 非信頼フックルーチンスタック領域

Release 1.4.0以降では必要ない．

6.23 ハードウェアカウンタ

ATK2-SC1から変更なし．

6.23.1 ハードウェアカウンタのファイル構成

ATK2-SC1から変更なし．

6.23.2 ハードウェアカウンタの情報提供

ATK2-SC1から変更なし．

6.24 OSAP強制終了

(6-24-1) void activate_force_term_osap_main(TCB *p_tcb)

OSAP強制終了時に呼ばれ，当該OSAPの終了処理を実施するリスタートタスクを
起動する関数である．
リスタートタスクの起動番地は，force_term_osap_mainラベルの番地とする．
force_term_osap_mainは，カーネル非依存部で提供するラベルであるため，
ターゲット依存部では提供しない．

activate_force_term_osap_mainの処理内容は次のとおり．

----------------------------------------
void
activate_force_term_osap_main(TCB *p_tcb)
{
	指定されたTCB（*p_tcb）中のスタックポインタを初期化する
	force_term_osap_mainを，実行再開番地として指定されたTCBに保存する
	return;
}
----------------------------------------


７．ジェネレータ設定ファイルのターゲット依存部

7.1 設定ファイルとターゲット依存部の位置付け

ATK2-SC3のジェネレータは，設定ファイルの記述に従ってファイルの生成およ
びエラーチェックを行う．ジェネレータの設定ファイルには，以下の5つがあ
る．

(a) XMLコンテナテーブル

ATK2-SC1から変更なし．

(b) 値取得シンボルテーブル

ATK2-SC1から変更なし．

(c) パス2のテンプレートファイル

ジェネレータのパス2は，テンプレートファイルに従って，カーネルの構成・
初期化ファイル（Os_Lcfg.c），構成・初期化ヘッダファイル（Os_Lcfg.h），
メモリ構成・初期化ファイル（kernel_mem2.c），リンカスクリプトファイル
（ldscript.ld），パス3, パス4に渡すテンプレート情報ファイル
(cfg2_out.tf)などを生成する．このテンプレートファイルは，ターゲット非
依存部とターゲット依存部に切り分けてあるが，他のファイルのターゲット依
存部とは逆に，ターゲット依存部からターゲット非依存部をインクルードする
形になっている．

具体的には，targetディレクトリに置かれたtarget.tfで，必要な変数を定義
した後，テンプレートファイルのターゲット非依存部（kernel/kernel.tf）を
インクルードする．kernel.tfでは，カーネルのターゲット非依存部で使用す
る変数定義等を生成する．kernel.tfをインクルードした後，target.tfでは，
カーネルのターゲット依存部で使用する変数定義等を生成する．target.tfか
ら，プロセッサ依存部，チップ依存部を，開発環境依存部を切り分けてもよい．

パス2では，メモリ構成・初期化ファイルに，meminib_table, memtop_table, 
datasecinib_table, bsssecinib_table, mpuinfo_shared(共有領域に対する
MPUINFOB)，OSAP専有領域に対するMPUINFOBの情報を出力する．

(d) パス3のテンプレートファイル

ジェネレータのパス3は，テンプレートファイルに従って，パス2で生成した，
meminib_table, memtop_table, datasecinib_table, bsssecinib_table,
mpuinfo_shared(共有領域に対するMPUINFOB), OSAP専有領域に対するMPUINFOB
の最適化を行う．このテンプレートファイルも，ターゲット非依存部とターゲ
ット依存部に切り分けてあり，ターゲット依存部からターゲット非依存部をイ
ンクルードする形になっている．

具体的には，targetディレクトリに置かれたtarget_mem.tfで，必要な変数を
定義した後，テンプレートファイルのターゲット非依存部
（kernel/kernel_mem.tf）をインクルードする．kernel_mem.tfでは，カーネ
ルのターゲット非依存部で，パス2で生成した各ファイルから情報を読込み，
メモリ構成・初期化データ構造の最適化（隣接領域の統合・0サイズ領域の削
除など）を行い，最適化したメモリ構成・初期化ファイル（kernel_mem3.c）
を出力する．target_mem.tfから，プロセッサ依存部，チップ依存部を，開発
環境依存部を切り分けてもよい．

(e) パス4のテンプレートファイル

ジェネレータのパス4は，テンプレートファイルに従って，パス3で生成した，
meminib_table, memtop_table, datasecinib_table, bsssecinib_table,
mpuinfo_shared(共有領域に対するMPUINFOB), OSAP専有領域に対するMPUINFOB
を更に最適化を行い，最終のメモリ構成・初期化ファイル（kernel_mem.c）を
出力する．このテンプレートファイルも，ターゲット非依存部とターゲット依
存部に切り分けてあり，ターゲット依存部からターゲット非依存部をインクル
ードする形になっている．

具体的には，targetディレクトリに置かれたtarget_mem2.tfで，必要な変数を
定義した後，テンプレートファイルのターゲット非依存部
（kernel/kernel_mem2.tf）をインクルードする．kernel_mem2.tfでは，カー
ネルのターゲット非依存部で，パス3で生成した各ファイルから情報を読込み，
メモリ構成・初期化データ構造再度最適化を行い，パス3と変わらない最終の
メモリ構成・初期化ファイル（kernel_mem.c）を出力する．target_mem.tfか
ら，プロセッサ依存部，チップ依存部を，開発環境依存部を切り分けてもよ
い．

ジェネレータのパス4は，基本的にはパス3と同じ処理を行うが，パス3と違い，
各メモリオブジェクトの開始と終端アドレスが最終のアドレスになるため，違
うメモリリージョンに配置されるメモリオブジェクトの統合や，リンカで配置
しないメモリオブジェクトの統合が可能になる．パス3とパス4ではメモリマッ
プが変わらないようにするため，パス4での最適化により，配列のサイズが小
さくできる場合でもサイズを変えないようにする．
ジェネレータのパス4では，メモリオブジェクトの重なりのチェック等のエラー
チェックも行う．

なお，ジェネレータの詳細仕様と設定ファイルの記述方法については，別途
PDFファイルの形で配布している「TOPPERS新世代カーネル用ジェネレータ仕様」
および「TOPPERS新世代カーネル用ジェネレータ内蔵マクロプロセッサ仕様」
を参照すること．

7.2 パス2のテンプレートファイルのターゲット依存部


7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数


(7-2-1-5) TARGET_SEC_ALIGN_STR	セクションのアラインサイズの定義
(7-2-1-6) TARGET_PAGE_SIZE_STR	ページのアラインサイズの定義

(7-2-1-7) TARGET_MEMATR_USTACK	ユーザスタック領域のメモリオブジェクト
                                属性

以下の標準セクションのメモリオブジェクト属性を定義する
(7-2-1-8) MEMATR_TEXT		コード領域の属性
(7-2-1-9) MEMATR_RODATA		読込み専用領域の属性
(7-2-1-10) MEMATR_DATA		データ領域の属性
(7-2-1-11) MEMATR_BSS		0初期化領域の属性
(7-2-1-12) MEMATR_PRSV		プレザーブド領域の属性
(7-2-1-13) MEMATR_SDATA		初期値ありショート領域の属性
(7-2-1-14) MEMATR_SBSS		初期値なしショート領域の属性

(7-2-1-15) START_OBJS		スタートアップモジュールの定義

(7-2-1-16) SECTION_USTACK	ユーザスタック領域のセクション名生成関数

(7-2-1-17) ALLOC_USTACK(taskid, ustksz)	ユーザスタック領域の確保関数

(7-2-1-18) USTACK_ALIGN_SIZE(ustksz)	ユーザスタックのアライメント制
                                        約に合わせたサイズを返す関数

(7-2-1-19) SECTION_SHARED_USTACK(共有スタックID)	基本タスクの共有ス
                                        タックのセクション名を返す関数

(7-2-1-20) ALLOC_SHARED_USTACK(...)	基本タスクの共有スタックの確保関数
  第1引数 共有スタック名
  第2引数 共有スタックID(タスク優先度)
  第3引数 スタックサイズ(アライメント調整済み)

(7-2-1-21) ALLOC_SSTACK(...)	システムスタック領域の確保関数
  第1引数 スタック名
  第2引数 スタックサイズ
  第3引数 変数定義に付与する指定子

(7-2-1-22) ALLOC_HSTACK(...)	非信頼フックスタックの確保関数
  第1引数 スタック名
  第2引数 スタックサイズ

  Release 1.4.0以降では必要ない．

(7-2-1-23) HSTACK_SIZE_STR(stksz)	非信頼フックスタックサイズのアライ
                                    メント制約を満たすように拡張したサ
                                    イズの文字列を返す関数
  Release 1.4.0以降では必要ない．

(7-2-1-24) DEFINE_DSEC(void)	標準のセクションの定義関数
  上記(7-2-1-9)〜(7-2-1-15)の標準のセクション(名前，属性，配置リージョ
  ン名)の定義

(7-2-1-25) SECTION_DESCRIPTION(secname)	リンクするセクション名記述の生
                                        成関数


(7-2-1-26) HOOK_ERRORCHECK_SEC(secid)（オプション）	ATT_SECに関するタ
                                     ーゲット依存のエラーチェック関数



(7-2-1-27) HOOK_ERRORCHECK_MEM(secid)（オプション）	ATT_MEMに関するタ
                                     ーゲット依存のエラーチェック関数

(7-2-1-28) TARGET_PROVIDE_GP(void)	gpレジスタの設定関数

(7-2-1-29) TARGET_CODE_FILLER(moid)（オプション）	text領域をNOP命令
                                                    で埋める関数
  text領域のシンボル名をNOP命令で埋める

(7-2-1-30) GENERATE_OUTPUT(void)（オプション）ターゲット依存のOUTPUT記
                                              述の生成関数
  出力するファイルの形式（BFD），ターゲットアーキテクチャ及びエントリ
  を指定する．

(7-2-1-31) GENERATE_PROVIDE(void)	ターゲット依存のPROVIDE記述の生成
                                    関数


(7-2-1-32) GENERATE_SECTION_FIRST(void)	ターゲット依存のセクション記述
                                        の生成関数

(7-2-1-33) GENERATE_STKMPUINFOB(taskid)	タスクスタックのMPUレジスタ設
                                        定値を出力する関数
  メモリサイズ確定のため，コンパイラ用ダミーのMPUレジスタ設定値を出力
  する．

(7-2-1-34) $CFG_PASS3 = 0$
(7-2-1-35) $CFG_PASS4 = 0$

また，パス2，パス3，パス4共通定義を共通処理ファイル(prc_common.tf)に定
義し，各パス処理テンプレートファイルを処理前にインクルードする．

(7-2-1-36) MEMORY_ALIGN		メモリのアライメント

(7-2-1-37) CHECK_MP_ALIGN	第1引数と，第2引数がメモリ保護のアライメン
                            ト制約を満たしているかチェックする関数

(7-2-1-38) GENERATE_OSAPINIB_MPUINFOB(osapid)	OSAPINIBのMPUINFOBを出
                                            力する関数

(7-2-1-39) DEFINE_CONST_VAR(...)		rodata領域に配置される変数を定
                                        義する関数
  第1引数 変数型名
  第2引数 変数名

DEFINE_CONST_VARは，非依存部のテンプレートファイルでは，データセクション
の初期化前に使用されるデータ（具体的には，ostkpt，tnum_datasec，
datasecinib_table）を確実に定数領域（初期化が必要なく，リセット後にも
値が保持される不揮発性領域）に配置するために用いられる．

(7-2-1-40) GENERATE_STKMPUINFOB(taskid)	タスクスタックのMPUレジスタ設
                                        定値を出力関数
  この関数は，パス3, パス4のみ有効な定義とする．
  上記(7-2-1-33)の定義は，パス2のみ有効

(7-2-1-41) DEFINE_VAR_SEC(...)		変数を指定されたセクションに定義す
                                    る関数
  第1引数 セクション名
  第2引数 型
  第3引数 変数名
  第4引数 変数の値

(7-2-1-42) GENERATE_TARGET_MPUINFOB(void)	MPUレジスタ設定値の生成関数
  MPU_REGIONを作成，統合し，共有領域及びOSAP専有領域のMPUレジスタ設定
  値を生成する．

(7-2-1-27) HOOK_ERRORCHECK_REG(regid)（オプション）	ATT_REGに関するタ
                                     ーゲット依存のエラーチェック関数

7.2.2 ターゲット非依存部で定義される変数

(7-2-2-3) REG.xxxx[regid]		メモリリージョンの連想配列

(7-2-2-4) MO.xxxx[moid]			メモリオブジェクトの連想配列

(7-2-2-5) LNKSEC.xxxx[lsid]		LNK_SECで配置するセクションの連想配列

(7-2-2-6) OSAP.xxxx[osapid]		OSAP情報の連想配列

7.3 パス3のテンプレートファイルのターゲット依存部

7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数

target_mem.tfからkernel_mem.tfをインクルードする前に，必要に応じて，次
の変数を定義しておかなければならない．

(7-3-1-2) $CFG_PASS3 = 1$
(7-3-1-3) $CFG_PASS4 = 0$

7.4 パス4のテンプレートファイルのターゲット依存部


以下では，パス4のテンプレートファイルのターゲット依存部を記述する上で
必要な事項について説明する．

7.4.1 ターゲット非依存部をインクルードする前に定義すべき変数

target_mem2.tfからkernel_mem2.tfをインクルードする前に，必要に応じて，
次の変数を定義しておかなければならない．

(7-4-1-1) $CFG_PASS3 = 0$
(7-4-1-2) $CFG_PASS4 = 1$

(7-4-1-3) HOOK_ERRORCHECK_MEM_PASS4(moid)（オプション）
 - OsMemoryAreaに関するターゲット定義のエラーチェック関数
 - 引数 moid：メモリオブジェクトのID
 - OsMemoryAreaStartAddress で指定された値が，MO.BASEADDR[moid]に
   入っているため，この値がターゲット定義のアライメント制約を満たして
   いるかどうかチェックし，アラインメント制約を満たしていない場合，
   エラーを検出する．≪NOS0813≫
 - OMIT_STANDARD_MEMINIBが定義されている場合，本関数は呼ばれない
   ため，ターゲット依存部のtfで，NOS0813のチェックをする必要がある．

また，各メモリオブジェクトの領域のサイズチェック・オブジェクトの重なり
チェックを必要に応じて，パス4で行う．

パス3とパス4ではメモリマップが変わらないようにするため，パス4での最適
化により，配列のサイズが小さくできる場合でもサイズを変えないようにす
る．


7.5 cfg1_out.cのリンクに必要なスタブの定義ファイル

----------------------------------------
...
void
initialize_sections(void)
{
}
const MPUINFOB		_background_code_region;
const MPUINFOB		_background_data_region;
----------------------------------------

7.6 data/bssセクション初期化ブロックの生成

ターゲット依存部において，OMIT_STANDARD_DATASECINIBマクロを定義すると，
ターゲット非依存部で，dataセクション初期化ブロックを生成しない．

ターゲット依存部において，OMIT_STANDARD_BSSSECINIBマクロを定義すると，
ターゲット非依存部で，bssセクション初期化ブロックを生成しない．

dataセクションなどの先頭番地のラベルは，使用するコンパイラによっては，
非依存部で生成される初期化ブロックから参照されるラベルと異なる場合が
ある．
そのような場合に，これらのマクロを定義することで，ターゲット依存で
独自のdata/bssセクション初期化ブロックの生成処理を，テンプレートファイル
によって定義することができる．

８．システムモジュール等のターゲット依存部

8.1 システムモジュールのターゲット依存部

ATK2-SC1から変更なし．

8.2 システムログ機能のターゲット依存定義

(8-2-3) ターゲット定義のシステムサービスの追加
システムログ機能は，ターゲット追加のシステムサービスとして位置付け，シ
ステムログ機能使用する/使用しない場合，システムサービステーブルに追加/
追加しないオプション（USE_KERNEL_LIBRARY_SYSLOG）をサポートする．

USE_KERNEL_LIBRARY_SYSLOGマクロが定義されている場合，システムモジュー
ルに用意している_kernel_KernelLibrarySyslog関数をターゲットで追加する
システムサービステーブル定義（PRC_SVC_TABLE）に追加する．
USE_KERNEL_LIBRARY_SYSLOGマクロが定義されない場合，
_kernel_KernelLibrarySyslog関数をターゲットで追加するシステムサービス
テーブル定義（PRC_SVC_TABLE）に追加しない．

8.3 シリアルインタフェースドライバのターゲット依存部

8.3.1 変数，データ型，管理関数

ATK2-SC1から変更なし．

8.3.2 デバイスサービスルーチン

ATK2-SC1から変更なし．

8.3.3 コールバックルーチン

ATK2-SC1から変更なし．

8.4 カーネル起動メッセージの出力のターゲット依存定義

ATK2-SC1から変更なし．

8.5 サンプルプログラムとテストプログラムのターゲット依存定義

ATK2-SC1から変更なし．

8.6 実行時間分布集計モジュールのターゲット依存定義

ATK2-SC1から変更なし．

8.7 タイマドライバ

8.7.1 タイマドライバのファイル構成

ATK2-SC1から変更なし．

8.7.2 ソフトウェアカウンタの定義

ATK2-SC1から変更なし．

8.7.3 時間型の定義

ATK2-SC1から変更なし．

8.7.4 タイマの初期化・終了処理・割込み処理

ATK2-SC1から変更なし．

8.7.5 現在の時刻の取得

ATK2-SC1から変更なし．

９．その他

9.1 ドキュメント

ATK2-SC1から変更なし．

１０．リファレンス

10.1 ターゲット依存部のファイル一覧

target_mem.tf			ジェネレータのパス3のテンプレートファイルのター
						ゲット依存部（7.3 節）．
target_mem2.tf			ジェネレータのパス4のテンプレートファイルのター
						ゲット依存部（7.4 節）．
target_mem.arxml		ターゲット依存の標準ROM/RAMなどメモリリージョ
						ン定義のXMLコンテナコンフィギュレーション
						ファイル．
target_svc.h			ターゲット依存のソフトウェア割込みによるサービ
						スコールインタフェースヘッダーファイル．
target_serial_obj.arxml	シリアルドライバのシステムコンフィギュレーショ
						ンファイル．
target_serial_osap.arxmlシリアルドライバのシステムコンフィギュレーショ
						ンファイル．
target_test_obj.arxml	テストプログラムのターゲット依存定義のコンフィ
						ギュレーションファイル．
target_test_osap.arxml	テストプログラムのターゲット依存定義のコンフィ
						ギュレーションファイル．
target_timer_obj.arxml	タイマドライバのXMLコンテナ用システムコンフィ
						ュレーションファイル．
target_timer_osap.arxml	タイマドライバのXMLコンテナ用システムコンフィ
						ュレーションファイル．


以上
