
		TOPPERS/ATK2-SC3-MC
		ターゲット依存部 ポーティングガイド

このドキュメントは，TOPPERS/ATK2-SC3-MCを，未サポートのターゲットシス
テムにポーティングするために必要となるターゲット依存部の実装方法を説明
するものである．

----------------------------------------------------------------------
TOPPERS ATK2
    Toyohashi Open Platform for Embedded Real-Time Systems
    Automotive Kernel Version 2

Copyright (C) 2011-2015 by Center for Embedded Computing Systems
            Graduate School of Information Science, Nagoya Univ., JAPAN
Copyright (C) 2011-2015 by FUJI SOFT INCORPORATED, JAPAN
Copyright (C) 2011-2013 by Spansion LLC, USA
Copyright (C) 2011-2015 by NEC Communication Systems, Ltd., JAPAN
Copyright (C) 2011-2015 by Panasonic Advanced Technology Development Co., Ltd., JAPAN
Copyright (C) 2011-2014 by Renesas Electronics Corporation, JAPAN
Copyright (C) 2011-2015 by Sunny Giken Inc., JAPAN
Copyright (C) 2011-2015 by TOSHIBA CORPORATION, JAPAN
Copyright (C) 2011-2015 by Witz Corporation
Copyright (C) 2014-2015 by AISIN COMCRUISE Co., Ltd., JAPAN
Copyright (C) 2014-2015 by eSOL Co.,Ltd., JAPAN
Copyright (C) 2014-2015 by SCSK Corporation, JAPAN
Copyright (C) 2015 by SUZUKI MOTOR CORPORATION

上記著作権者は，以下の (1)〜(3)の条件を満たす場合に限り，本ドキュメ
ント（本ドキュメントを改変したものを含む．以下同じ）を使用・複製・改
変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
(1) 本ドキュメントを利用する場合には，上記の著作権表示，この利用条件
    および下記の無保証規定が，そのままの形でドキュメント中に含まれて
    いること．
(2) 本ドキュメントを改変する場合には，ドキュメントを改変した旨の記述
    を，改変後のドキュメント中に含めること．ただし，改変後のドキュメ
    ントが，TOPPERSプロジェクト指定の開発成果物である場合には，この限
    りではない．
(3) 本ドキュメントの利用により直接的または間接的に生じるいかなる損害
    からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，
    本ドキュメントのユーザまたはエンドユーザからのいかなる理由に基づ
    く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

本ドキュメントは，AUTOSAR（AUTomotive Open System ARchitecture）仕様
に基づいている．上記の許諾は，AUTOSARの知的財産権を許諾するものではな
い．AUTOSARは，AUTOSAR仕様に基づいたソフトウェアを商用目的で利用する
者に対して，AUTOSARパートナーになることを求めている．

本ドキュメントは，無保証で提供されているものである．上記著作権者およ
びTOPPERSプロジェクトは，本ドキュメントに関して，特定の使用目的に対す
る適合性も含めて，いかなる保証も行わない．また，本ドキュメントの利用
により直接的または間接的に生じたいかなる損害に関しても，その責任を負
わない．

$Id: porting.txt 499 2015-12-23 07:03:13Z ertl-ishikawa $
----------------------------------------------------------------------

○目次

◎０．前提
	◎0.1 本マニュアルの位置づけ
	◎0.2 動作アーキテクチャ
１．共通事項
	1.1 ターゲット依存部の構成
	1.2 多重インクルードの防止
	1.3 アセンブリ言語とのヘッダファイルの共用 
	1.4 インクルード記述の方法
	1.5 クリティカルセクションの出入処理の実現に関する制約
２．システム構築環境のターゲット依存部
	2.1 ターゲット略称とターゲット依存部のディレクトリ
	2.2 Makefileのターゲット依存部
	2.3 開発環境名とコマンド名の設定
	2.4 コンパイルオプションとオブジェクトファイルの設定
	2.5 オフセットファイルの生成方法
		2.5.1 ジェネレータを用いる方法
	2.6 リンク方法の設定
	2.7 依存関係の定義
	2.8 その他の設定
３．AUTOSAR共通定義のターゲット依存部
	3.1 整数型の最大値・最小値・ビット数
	3.2 整数型
	3.3 論理型，論理型の値
	3.4 その他の型
	3.5 コンパイラの拡張機能のためのマクロ定義
	3.6 標準的な定義の上書き
４．システムインタフェースレイヤ（SIL）のターゲット依存部
	○4.1 全割込み禁止状態の管理
	4.2 プロセッサのエンディアン
	4.3 I/O空間アクセス関数
	◎4.4 スピンロック機能
	◎4.5 コアIDの取得
５．カーネルAPIのターゲット依存部
	5.1 メモリ領域確保のための型定義
	5.2 メモリ領域確保のためのマクロ
	○5.3 オブジェクト型の上書き
６．カーネル実装のターゲット依存部
	6.1 カーネル実装のターゲット依存部の共通事項
		6.1.1 カーネル実装のターゲット依存部の構成要素
		6.1.2 ターゲット依存部の関数の命名規則
	6.2 トレースログ機能への対応
	6.3 システム状態の管理
		6.3.1 全割込み禁止状態の管理
		6.3.2 コンテキストの管理
		6.3.3 OS割込み禁止状態の管理
	6.4 割込みに関連するシステム状態の管理
		6.4.1 割込み優先度マスクの管理
		6.4.2 割込みハンドラの先頭処理と末尾処理
		6.4.3 個別割込み禁止状態の管理
	6.5 タスクディスパッチャ
		6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック
		○6.5.2 ディスパッチャ本体
		○6.5.3 タスクコンテキストからのディスパッチ
		○6.5.4 ディスパッチャの動作開始
		6.5.5 現在のコンテキストを捨ててディスパッチ
		6.5.6 タスクの起動処理
	○6.6 割込みハンドラ
		○6.6.1 割込みハンドラの出入口処理
		6.6.2 割込み要求ラインの属性の設定
		6.6.3 割込み管理機能の初期化処理の変更
		6.6.4 デフォルトのC2ISR
		6.6.5 カーネル管理外の割込み
		6.6.6 DisableAllInterrupts/EnableAllInterruptsの処理内容の変更
		6.6.7 割込み禁止解除
		◎6.6.8 割込み番号のマルチコア拡張
	6.7 スタックモニタリング
		6.7.1 ディスパッチャとC2ISRの出入口処理でのスタック
		モニタリング
		6.7.2 信頼関数実行の出口処理でのスタックモニタリング
	6.8 CPU例外ハンドラ
	6.9 ソフトウェア割込みハンドラ
	6.10 信頼OSAPと非信頼OSAPからのシステムサービス呼出し
		6.10.1 システムサービス呼出しの定義
		6.10.2 信頼OSAPからのシステムサービス呼出し
		6.10.3 非信頼OSAPからのシステムサービス呼出し
		6.10.4 ターゲット依存システムサービスの追加
	6.11 メモリ保護機構（MPU）制御
		6.11.1 スタックのMPU設定情報ブロック（STKMPUINFOB）
		6.11.2 OSAP固有MPU設定情報ブロック（OSAPMPUINFOB）
		6.11.3 MPU初期化処理
		6.11.4 OSAP固有MPU情報設定処理
		6.11.5 MPU依存のバックグラウンド領域チェック
	6.12 メモリ管理のチューニング
		6.12.1 メモリオブジェクトの管理
		6.12.2 メモリアクセス権チェックのためのマクロ
	6.13 エラーフック，シャットダウンフック呼び出し
	○6.14 カーネルの起動・終了とスタック領域など
	6.15 カーネル内部のチューニング
		6.15.1 ビットマップサーチ
	6.16 カーネル実装に関するその他の定義
		6.16.1 エラーチェック方法の指定
		6.16.2 非タスクコンテキスト用のスタック領域
		6.16.3 空ラベルの定義
		6.16.4 各スタックのデフォルト値
		6.16.5 スタックマジックナンバー領域操作マクロの定義
		6.16.6 標準以外メモリリージョン属性の定義
	6.17 トレースログ機能に関する設定
		6.17.1 取得できるトレースログの種類とマクロ
		6.17.2 トレースログ記録のサンプルコード
	6.18 信頼フック，シャットダウンフックの強制終了
	6.19 コア起動
	6.20 フックの確認
	6.21 スタック切り替え
	6.22 非信頼フックルーチンスタック領域
	◎6.23 コア識別
		◎6.23.1 コアID
		◎6.23.2 マスタコア
		◎6.23.3 ハードウェアに存在するコア数
	◎6.24 ロック
		◎6.24.1 ロック単位
		◎6.24.2 ロック方式
		◎6.24.3 ロック変数の型定義
		◎6.24.4 ロック操作関数
	◎6.25 コア間割込みドライバ
		◎6.25.1 コア間割込みドライバのファイル構成
		◎6.25.2 コア間割込みの初期化・終了処理・割込み処理
		◎6.25.3 コア間割込みの発行とクリア
		◎6.25.4 コア間割込みハンドラの登録
	◎6.26 コアコントロールブロック
	6.27 ハードウェアカウンタ
		6.27.1 ハードウェアカウンタのファイル構成
		○6.27.2 ハードウェアカウンタの情報提供
	6.28 OSAP強制終了
７．ジェネレータ設定ファイルのターゲット依存部
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2のテンプレートファイルのターゲット依存部
		7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数
		7.2.2 ターゲット非依存部で定義される変数
		◎7.2.3 マルチコア関連の定義（関数）
		◎7.2.4 コア毎のデータ構造の配置場所
	7.3 パス3のテンプレートファイルのターゲット依存部
		7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数
	◎7.4 パス4のテンプレートファイルのターゲット依存部
		◎7.4.1 ターゲット非依存部をインクルードする前に定義すべき変数
	7.5 cfg1_out.cのリンクに必要なスタブの定義ファイル
８．システムモジュール等のターゲット依存部
	8.1 システムモジュールのターゲット依存部
	8.2 システムログ機能のターゲット依存定義
	8.3 シリアルインタフェースドライバのターゲット依存部
		8.3.1 変数，データ型，管理関数
		8.3.2 デバイスサービスルーチン
		8.3.3 コールバックルーチン
	8.4 カーネル起動メッセージの出力のターゲット依存定義
	8.5 サンプルプログラムとテストプログラムのターゲット依存定義
	8.6 実行時間分布集計モジュールのターゲット依存定義
	8.7 タイマドライバ
		8.7.1 タイマドライバのファイル構成
		8.7.2 ソフトウェアカウンタの定義
		8.7.3 時間型の定義
		8.7.4 タイマの初期化・終了処理・割込み処理
		8.7.5 現在の時刻の取得
９．その他
	○9.1 ドキュメント
１０．リファレンス
	○10.1 ターゲット依存部のファイル一覧

○がついている項目はATK2-SC3から変更があった箇所を，◎はATK2-SC3-MCで
新規に追加された箇所を示し，それぞれ差分のみを記述している．


０．前提

0.1 本マニュアルの位置づけ

TOPPERS/ATK2-SC3-MCは，シングルコア向けのTOPPERS/ATK2-SC3をベースとし
ているため，多くのポーティング項目はTOPPERS/ATK2-SC3と同一である．
そのため，TOPPERS/ATK2-SC3-MCをポーティングする前に，TOPPERS/ATK2-SC3
をポーティングすることを推奨する．本ドキュメントでは，TOPPERS/ATK2-SC3
からのポーティングに関して説明する．

0.2 動作アーキテクチャ

ATK2-SC3-MCを動作させるシステムは，次のアーキテクチャ（コア/バス/メモ
リ）を満たさなければならない．

(0-2-1) アドレス

各コアで，プログラムや固定データに対して，同一アドレスでアクセス可能で
あること．それぞれのプロセッサがアクセスする物理的なメモリが異なってい
てもよい．

(0-2-2) 共有メモリ

全コアから，同一のアドレスでアクセス可能なRAMがあること．（カーネルの
コントロールブロックはこの領域に配置する．）

(0-2-3) コア間割込み機能

任意のコアに割込み（コア間割込み）を発生可能であること．

(0-2-4) コア間排他制御機能

コア間での排他制御のための機構を持つこと．
  例 : test & set 命令， Mutex回路

(0-2-5) ロックの個数

コア間の排他制御機構を用いてロックを最低1個作成可能であること．1個のみ
の場合はジャイアントロック方式のみサポート可能．2個+コア毎に2個作成可
能であるとコアロック方式をサポート可能．

(0-2-6) コアID

各コアがユニークなIDを持ち，それをソフトウェアで読み込むことにより，自
コアを判別可能であること．


１．共通事項

1.1 ターゲット依存部の構成

ATK2-SC3から変更なし．

1.2 多重インクルードの防止

ATK2-SC3から変更なし．

1.3 アセンブリ言語とのヘッダファイルの共用 

ATK2-SC3から変更なし．

1.4 インクルード記述の方法

ATK2-SC3から変更なし．

1.5 クリティカルセクションの出入処理の実現に関する制約

ATK2-SC3から変更なし．


２．システム構築環境のターゲット依存部

2.1 ターゲット略称とターゲット依存部のディレクトリ

ATK2-SC3から変更なし．

2.2 Makefileのターゲット依存部

ATK2-SC3から変更なし．

2.3 開発環境名とコマンド名の設定

ATK2-SC3から変更なし．

2.4 コンパイルオプションとオブジェクトファイルの設定

ATK2-SC3から変更なし．

2.5 オフセットファイルの生成方法

ATK2-SC3から変更なし．

2.5.1 ジェネレータを用いる方法

ATK2-SC3から変更なし．

2.6 リンク方法の設定

ATK2-SC3から変更なし．

2.7 依存関係の定義

ATK2-SC3から変更なし．

2.8 その他の設定

ATK2-SC3から変更なし．


３．AUTOSAR共通定義のターゲット依存部

3.1 整数型の最大値・最小値・ビット数

ATK2-SC3から変更なし．

3.2 整数型

ATK2-SC3から変更なし．

3.3 論理型，論理型の値

ATK2-SC3から変更なし．

3.4 その他の型

ATK2-SC3から変更なし．

3.5 コンパイラの拡張機能のためのマクロ定義

ATK2-SC3から変更なし．

3.6 標準的な定義の上書き

ATK2-SC3から変更なし．


４．システムインタフェースレイヤ（SIL）のターゲット依存部

全割込み禁止状態の管理はコア毎に行う．

4.1 全割込み禁止状態の管理

(4-1-1) SIL_PRE_LOC

全割込み禁止フラグの状態を保存するための変数を定義するマクロ．コア毎に
独立した変数を用意する．

(4-1-2) SIL_LOC_INT()

呼び出したコアにおいて，現在の全割込み禁止フラグの状態をSIL_PRE_LOCで
定義した変数に保存し，全割込み禁止状態に遷移させるマクロ．

(4-1-3) SIL_UNL_INT()

呼び出したコアにおいて，SIL_LOC_INT()によって変数に保存した状態に戻す
マクロ．

4.2 プロセッサのエンディアン

ATK2-SC3から変更なし．

4.3 I/O空間アクセス関数

ATK2-SC3から変更なし．

4.4 スピンロック機能

SILのターゲット依存部では，スピンロックを用いたコア間の排他制御機能の
実現のため，スピンロックを取得する機能とスピンロックを返却する機能を提
供する．

SILの機能は，カーネルを使用しない場合にも使用できる必要がある．そのた
め，スピンロックの取得と解放は，カーネルを用いず，プロセッサのリソース
を直接操作することによって実現する．

スピンロックはカーネルが使用するものとは別に，システムインタフェースレ
イヤ用に確保する．使用するスピンロックは，カーネル起動時にターゲット依
存部で初期化すること．

(4-4-1) SIL_LOC_SPN

システムインタフェースレイヤ用のスピンロックを取得するマクロ．このマク
ロを実現する際には，「1.5 クリティカルセクションの出入処理の実現に関す
る制約」の節に記述されている制約に従わなければならない．SIL_LOC_SPNは，
SIL_LOC_INTの機能を包含する．すなわち，SIL_LOC_SPNに成功すると全割込み
ロック状態になる．また，SIL_LOC_INT と同様に，用いる関数またはブロック
の先頭の変数宣言部に SIL_PRE_LOC を記述しなければならない．

(4-4-2) SIL_UNL_SPN

システムインタフェースレイヤ用のスピンロックを返却するマクロ．このマク
ロを実現する際には，「1.5 クリティカルセクションの出入処理の実現に関す
る制約」の節に記述されている制約に従わなければならない．

(4-4-3) TOPPERS_sil_force_unl_spn

システムインタフェースレイヤ用のスピンロックを取得している場合に解放す
る関数．割込み禁止状態は変更しない．この関数は，カーネル内部からのみ呼
び出す．

4.5 コアIDの取得

(4-5-1) sil_get_coreid(ID *p_coreid)

呼び出したコアのコアIDを取得する．


５．カーネルAPIのターゲット依存部

5.1 メモリ領域確保のための型定義

ATK2-SC3から変更なし．

5.2 メモリ領域確保のためのマクロ

ATK2-SC3から変更なし．

5.3 オブジェクト型の上書き

(5-3-1) OMIT_DATA_TYPE (オプション)

OMIT_DATA_TYPEマクロをターゲット依存部で定義した場合は，一部のオブジェ
クトの型をターゲット依存部で定義することができる．

(5-3-18) CoreIdType           (オプション，デフォルトはuint8)
(5-3-19) SpinlockIdType       (オプション，デフォルトはuint32)


６．カーネル実装のターゲット依存部

6.1 カーネル実装のターゲット依存部の共通事項

6.1.1 カーネル実装のターゲット依存部の構成要素

カーネル実装のターゲット依存部は，以下の要素で構成される．

(d) コア間割込みドライバ

コア間で割込みを発生させるためのコア間割込みドライバのヘッダファイル，
実装ファイルを，それぞれ，target_ici.h，target_ici.cに含める．プロセッ
サ・チップ・開発環境依存部を切り分けることも可能である．

6.1.2 ターゲット依存部の関数の命名規則

ATK2-SC3から変更なし．

6.2 トレースログ機能への対応

ATK2-SC3から変更なし．

6.3 システム状態の管理

ATK2-SC3から変更なし．

6.3.1 全割込み禁止状態の管理

ATK2-SC3から変更なし．

6.3.2 コンテキストの管理

ATK2-SC3から変更なし．

6.3.3 OS割込み禁止状態の管理

ATK2-SC3から変更なし．

6.4 割込みに関連するシステム状態の管理

6.4.1 割込み優先度マスクの管理

ATK2-SC3から変更なし．

6.4.2 割込みハンドラの先頭処理と末尾処理

ATK2-SC3から変更なし．

6.4.3 個別割込み禁止状態の管理

ATK2-SC3から変更なし．


6.5 タスクディスパッチャ

6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック

ATK2-SC3から変更なし．

6.5.2 ディスパッチャ本体

ディスパッチャ本体で扱うp_runtsk/p_schedtsk/callevel_stat/p_runosap
は，自コアのccb(my_ccb)が保持しているものとし，OS割込み禁止状態はディ
スパッチャ本体を実行しているコアを対象とする以外，ATK2-SC3から変更な
し．
例えば，ATK2-SC3でのp_runtskはATK2-SC3-MCの場合，my_ccb.p_runtskとな
り，callevel_statはmy_ccb.callevel_statとなる．

6.5.3 タスクコンテキストからのディスパッチ

ディスパッチ（dispatch）で扱うp_runtskやp_schedtskは，自コアのccb
(my_ccb)が保持しているものとする．

6.5.4 ディスパッチャの動作開始

ディスパッチャの動作開始（start_dispatch）で扱うOS割込み禁止状態・割込
み優先度マスクは，start_dispatchを実行しているコアのものを対象とする．

6.5.5 現在のコンテキストを捨ててディスパッチ

ATK2-SC3から変更なし．

6.5.6 タスクの起動処理

ATK2-SC3から変更なし．

6.6 割込みハンドラ

マルチコアのハードウェア割込みのタイプは大きく二つに分けることができ
る．1つ目は，単一の割込みコントローラを全てのコアで共有しており，割込
みを任意のコアで受け付けることが出来るタイプで，SMP割込み型と呼ぶ．も
う一方は，コア毎に割込みコントローラを持ち，割込みは特定のコアに固定さ
れているタイプで，AMP割込み型と呼ぶ．

割込み番号と割込みハンドラ番号を引数とする関数については，上位ビットフ
ィールドに（32bitの場合は上位16bit）に割込みを受け付けるコアのコアIDが
指定された値が渡されるため，必要に応じてマスクしてから扱うこと．

割込み管理のための管理ブロックは，ターゲット依存部のジェネレータテンプ
レートファイル（target.tf）内で生成する．SMP割込みの場合は，システムで
単一の管理ブロックを生成するのが一般的であり，AMP割込みの場合は，コア毎
に管理ブロックを生成するのが一般的である．

6.6.1 割込みハンドラの出入口処理

C2ISRの割込みの出入口処理で扱うp_runtsk/p_runisr/callevel_stat/
p_runosapは，自コアのccb(my_ccb)が保持しているものとする以外，ATK2-SC3
から変更なし．

6.6.2 割込み要求ラインの属性の設定

ATK2-SC3から変更なし．

6.6.3 割込み管理機能の初期化処理の変更

ATK2-SC3から変更なし．

6.6.4 デフォルトのC2ISR

ATK2-SC3から変更なし．

6.6.5 カーネル管理外の割込み

ATK2-SC3から変更なし．

6.6.6 DisableAllInterrupts/EnableAllInterruptsの処理内容の変更

ATK2-SC3から変更なし．

6.6.7 割込み番号のマルチコア拡張

割込み番号に関しては，複数のコアに接続された割込み要求ラインに対して
は，割込み番号の上位ビットを0とし，1つのコアのみに接続された割込み要求
ラインに対しては，割込み番号の上位ビット(32bitの場合は上位16bit)に接続
されたコアの(ID番号+1)を含める．例えば，コアID 1 のコアのみに接続され
た識別番号が 3 の割込み要求ラインの32bitCPUでの割込み番号は，
0x00020003 となる．

6.7 スタックモニタリング

ATK2-SC3では，call_protectionhook_mainを呼び出す直前で，
pre_protection_supervised = TRUE;
としていたが，これを，
<自コアのCCB>.pre_protection_supervised = TRUE;
とする．

6.8 CPU例外ハンドラ

ATK2-SC3から変更なし．

ただし，スタック領域などコア毎に管理しているものを，自コア管理のものを
使用するという拡張を行う必要がある．

また，ATK2-SC3では，call_protectionhook_mainを呼び出す直前で，
pre_protection_supervised = [TRUE|FALSE];
としていたが，これを，
<自コアのCCB>.pre_protection_supervised = [TRUE|FALSE];
とする．

6.9 ソフトウェア割込みハンドラ

ATK2-SC3から変更なし．

6.10 信頼OSAPと非信頼OSAPからのシステムサービス呼出し

ATK2-SC3から変更なし．

6.10.1 システムサービス呼出しの定義

ATK2-SC3から変更なし．

6.10.2 信頼OSAPからのシステムサービス呼出し

ATK2-SC3から変更なし．

6.10.3 非信頼OSAPからのシステムサービス呼出し

ATK2-SC3から変更なし．

6.10.4 ターゲット依存システムサービスの追加

ATK2-SC3から変更なし．

6.11 メモリ保護機構（MPU）制御

6.11.1 スタックのMPU設定情報ブロック（STKMPUINFOB）

ATK2-SC3から変更なし．

6.11.2 OSAP固有MPU設定情報ブロック（OSAPMPUINFOB）

ATK2-SC3から変更なし．

6.11.3 MPU初期化処理

ATK2-SC3から変更なし．

6.11.4 OSAP固有MPU情報設定処理

ATK2-SC3から変更なし．

6.11.5 MPU依存のバックグラウンド領域チェック

ATK2-SC3から変更なし．

6.12 メモリ管理のチューニング

6.12.1 メモリオブジェクトの管理

ATK2-SC3から変更なし．

6.12.2 メモリアクセス権チェックのためのマクロ

ATK2-SC3から変更なし．

6.13 エラーフック，シャットダウンフック呼び出し

ATK2-SC3から変更なし．

6.14 カーネルの起動・終了とスタック領域など

(6-14-1) スタートアップモジュール

スタートアップモジュールでは，プロセッサのモード設定やスタックポインタ
の設定といった，各コアのプライベートな設定は各コアで行う．一方，共有メ
モリのbssセクションのクリアと，dataセクションの初期化といった，共有リ
ソースの初期化処理は可能な限りマスタコアで行う．

マスタコア以外は，StartCoreによるコア起動要求を待ち合わせる．StartCore
要求後StartOSを呼び出し，カーネルの起動を行う．
以下はAUTOSAR OSの起動に関する仕様をマスタ-スレーブ方式のエミュレート
で実現した場合の内容である．

(a) 自ハードウェアの初期化

システムのリセット後すぐに各コアで行う必要のある初期化処理を行う．

(b) hardware_init_hookの呼び出し

システムのリセット後すぐに行う必要のあるターゲットシステム依存の初期化
処理を行う．SMPタイプのハードウェアでは，マスタコアのみ実行するのが一
般的である．プライベートリソースが存在する場合はそれぞのコアで初期化す
る．

(c) initialize_sectionsの呼び出し

C言語を動作させるための，bss/dataメモリの初期化を行う．マスタコアのみ
行うのが一般的である．プライベートメモリは，それぞれのコアで初期化す
る．

(d) StartCore待ち

スレーブコアでは，StartCoreで起動要求が実行されるまで，ループなどで待
ちとする．マスタコアであれば待ちは実施しない．

(d) software_init_hook()の呼び出し

開発環境（特にライブラリ）に依存して必要な初期化処理を行う．一般的には，
マスタコアのみで行う．

(e) target_hardware_initializeを呼び出す

ATK2-SC3から変更なし．

(f) mainへ分岐

mainを呼び出す．mainの中でStartOSが呼ばれる．
マスタコアであれば，StartOS前に起動が必要なスレーブコアに対し，
StartCoreを行なう．

(g) バリア同期

StartOS内で，アプリケーションモードの決定前，システム定義スタートアッ
プフック実行前，OSAP固有スタートアップフックの実行後のカーネル動作前に
それぞれ同期を行う．

(6-14-2) void target_initialize(void)

ATK2-SC3から変更なし．

(6-14-3) void target_exit(void)

ATK2-SC3から変更なし．

(6-14-4) OMIT_BARRIER_SYNC

カーネルの動作スタート/終了時用のバリア同期の関数を共通部で定義された
物ではなく，依存部で用意した関数を用いる場合に定義する．

(6-14-5) void barrier_sync(uint8 phase, boolean check_ext_ker);

カーネルの動作スタート/終了時用のバリア同期の関数．OMIT_BARRIER_SYNCを
定義して，ターゲット依存部でバリア同期の関数を定義する場合にこの仕様で
定義する．引数のphaseは同期のフェーズが指定される．check_ext_kerは同期
中にシャットダウン要求が発生したか確認の必要がある同期フェーズかどうか
の指定を行う．

(6-14-6) カーネルの終了

ShutdownAllCores()を呼び出されたコアから他のコアに対して終了処理を要求
してシステム全体をシャットダウンさせる．

(a)他のコアへの通知

標準では，共通部で用意されているディスパッチ要求用のコア間割込みを流用
した関数を用いる．ターゲット依存部で定義したい場合は，後述のマクロを定
義すればよい．

(b)OSAP固有シャットダウンフックの呼び出し

シャットダウンを行うコアに割り付けたOSAP固有のシャットダウンフックを順
次呼び出す．

(c)バリア同期

各コアでOSAP固有シャットダウンフック実行の終了を待ち合わせる．

(d)システム定義シャットダウンフックの呼び出し

各コアでシステム定義シャットダウンフックの呼び出しを行う．

(e)target_exit()の呼び出し

target_exit()を呼び出して，ターゲット依存部の終了処理を行い，その後無
限ループで終了となる．

(6-14-7) 終了処理関連の関数

ターゲット依存部では，カーネル終了処理要求関数（必要ならば）用意する．
バリア同期関数に関しては，起動処理と同じ関数を用いるため，終了処理用に
用意する必要はない．

(6-14-7-1) OMIT_KER_REQ_ON_ICI

他のコアに対するカーネル終了処理要求をディスパッチ要求用のコア間割込み
ハンドラで兼用させない場合に定義する．

(6-14-7-2) void shutdown_request(void)

他のコアに対するカーネル終了処理要求をディスパッチ要求用のコア間割込み
ハンドラで兼用させない場合に，ターゲット依存部で用意する．
カーネル終了処理関数（ShutdownAllCores()）で呼び出される．

6.15 カーネル内部のチューニング

6.15.1 ビットマップサーチ

ATK2-SC3から変更なし．

6.16 カーネル実装に関するその他の定義

6.16.1 エラーチェック方法の指定

ATK2-SC3から変更なし．

6.16.2 非タスクコンテキスト用のスタック領域

ATK2-SC3から変更なし．

6.16.3 空ラベルの定義

ATK2-SC3から変更なし．

6.16.4 各スタックのデフォルト値

ATK2-SC3から変更なし．

6.16.5 スタックマジックナンバー領域操作マクロの定義

(6-16-5-2) TOPPERS_SSTK_MAGIC_REGION（オプション）

スタックモニタリングで使用するタスクシステムスタック用マジックナンバー
の格納位置を返すマクロであり，スタックの成長方向がアドレスの大きい方か
ら小さい方へ成長することをデフォルト実装としている．スタック成長方向に
よりターゲットで再定義することができる．p_tinibで指定ししたタスク初期
化ブロックを基づいて，スタック成長方向によりターゲットで再定義すること
ができる．

6.16.6 標準以外メモリリージョン属性の定義

ハードウェアにどのような性質のメモリリージョンが存在するかは，ターゲッ
トに依存するので，標準ROM，標準RAM以外のメモリリージョンが存在する場合，
ターゲット依存部で，属性を識別するため以下のマクロを定義する．

(6-16-6-1)TARGET_REGATR

ただし，非依存部で以下の定義値は，既にビット単位で予約されているので，
定義値を注意する．
    0x00    /* オブジェクト属性を指定しない */
    0x01    /* 書込みアクセス禁止 */

コンフィギュレーション時，非依存部のでTARGET_REGATRを用いて，定義した
メモリリージョンの有効性をチェックしている．

6.17 トレースログ機能に関する設定

6.17.1 取得できるトレースログの種類とマクロ

ATK2-SC3から変更なし．

6.17.2 トレースログ記録のサンプルコード

ATK2-SC3から変更なし．

6.18 フック，シャットダウンフックの強制終了

ATK2-SC3から変更なし．

6.19 コア起動

ATK2-SC3から変更なし．

6.20 フックの確認

ATK2-SC3から変更なし．

6.21 スタック切り替え

ATK2-SC3から変更なし．

6.22 非信頼フックルーチンスタック領域

ATK2-SC3から変更なし．

6.23 コア識別

6.23.1 コアID

コアIDは，0から連続した番号を個々のコアに割り付けたものである．どのコ
アにどのIDを割り付けるかは，ターゲット依存で決める．

ターゲット依存部は，実行中のコアのコアIDを判別する機能を提供する．

(6-23-1-1) CoreIdType x_core_id(void)

処理単位が実行されているコアのIDを返す関数．ハードウェアの持つ
コア識別(HW-ID)のためのIDからコアIDを求めて返す．
HW-IDが0から連続した値でない場合には，この関数内で適切に変換する．

target_ccb.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

6.23.2 マスタコア

システム中の特定の1個のコアを示す．マスタコアは，他コアの起動等を
行う．どのコアをマスタコアとするかは，ターゲット依存で決定する．ターゲ
ット依存部では，実行中のコアがマスタコアかを判別する機能を提供する．

(6-23-2-1) boolean x_sense_mcore(void)

処理単位が実行されているコアがマスタコアならTRUE，マスタコアでなければ
FALSEを返す関数．

(6-23-2-2) OS_CORE_ID_MASTER

マスタコアのIDをカーネル共通構成マクロとして定義する．

6.24 ロック

6.24.1 ロック単位

ターゲット依存部では，ロック単位の違いによる2種類のロック単位のうちの
一つを選択する．

(6-24-1-1) TTYPE_KLOCK

ロック単位を指定するマクロ．指定可能な単位は以下のロック単位のうちのい
ずれかである．

target_ccb.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

(6-24-1-2) G_KLOCK   ジャイアントロック

ジャイアントロックを有効にするマクロ．ジャイアントロックは，システムで
1つのロックを使用する．すべてのシステムサービスが排他的に実行される．

(6-24-1-3) C_KLOCK  コアロック

コアロックを有効にするマクロ．コア毎にタスクロックとカウンタロックと，
全体でスピンロックロックとIOCロックを用いる方式．コア数 x 2 + 2個のロ
ックが必要．異なるコアに割り付けられている実行単位へのシステムサービス
は同時に実行可能．また，異なるオブジェクトロックコアに割り付けられてい
るオブジェクトへのシステムサービスは同時に実行可能．

6.24.2 ロック方式

ターゲット依存部では，スピンロックを実現するための排他制御におけるロッ
ク方式(排他制御ハードウェアの割当て方，ロックアルゴリズム)を選択する．

(6-24-2-1) TTYPE_SPN

ロック方式(スピンロック)を指定するマクロ．指定可能な方式は以下のロック
方式である．

(6-24-2-2) TAS_SPN	エミュレートTASスピンロック

エミュレートTASスピンロックを有効にするマクロ．エミュレート方式である
ためスピンロックサービスの排他制御のロジックをソフトウェアで実装する．
なお，Test and Set スピンロックアルゴリズムであるため，システムにおけ
るコア数が3つ以上の場合，OS処理性能における最悪実行時間の予測は不可能
である．

現状の実装では，ロック方式指定マクロTTYPE_SPNに，TAS_SPNの1方式しか指
定できないので，TTYPE_SPNマクロとTAS_SPNマクロを省略している．

6.24.3 ロック変数の型定義

ターゲット依存部は，ロック形式毎にロック変数の型を定義する．なお，使用
しないロック形式については定義する必要はない．

target_ccb.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

(6-24-3-1) LockType 

ロック変数の型．target_ccb.hまたはそこからインクルードされるファイル
（プロセッサ・チップ・開発環境依存部で用意されるヘッダファイルなど）に
含める．

ジャイアントロック方式時は，ロック変数はグローバル変数として mc.c 内で
宣言される．

コアロック方式の場合は，タスクロック変数とカウンタロック変数はタスクロ
ック，カウンタロック共にCCB内で宣言される．スピンロックロックとIOCロッ
クについてはグローバル変数としてmc.c 内で宣言される．

6.24.4 ロック操作関数

ターゲット依存部は，ロック形式毎にロックを操作する機能を提供する．これ
らは，使用しないロック形式の機能は定義する必要はない．各ロック形式と定
義する関数の対応表を以下に示す．

                                     G_KLOCK  C_KLOCK
x_initialize_giant_lock()              ○
x_initialize_tsk_lock()                         ○
x_initialize_cnt_lock()                         ○
x_initialize_spn_lock()                         ○
x_initialize_ioc_lock()                         ○
x_acquire_lock()                       ○       ○
x_release_lock()                       ○       ○

(6-24-4-1) void x_initialize_giant_lock(LockType *p_giant_lock)

ジャイアントロック方式の初期化関数．カーネル起動時にマスタコアから呼び
出される．

(6-24-4-2) void x_initialize_tsk_lock(LockType *p_tsk_lock)

コアロック方式でのタスクロックの初期化関数．カーネル起動時に自コアのタ
スクロックを対象に呼び出される．

(6-24-4-3) void x_initialize_cnt_lock(LockType *p_obj_lock)

コアロック方式でのカウンタロックの初期化関数．カーネル起動時に自コアの
カウンタロックを対象に呼び出される．

(6-24-4-4) void x_initialize_spn_lock(LockType *p_tsk_lock)

コアロック方式でのスピンロックロックの初期化関数．カーネル起動時にマス
タコアから呼び出される．

(6-24-4-5) void x_initialize_spn_lock(LockType *p_tsk_lock)

コアロック方式でのIOCロックの初期化関数．カーネル起動時にマスタコアか
ら呼び出される．

(6-24-4-6) void x_acquire_lock(LockType *p_lock);

1段目のロック取得関数．OS割込み禁止状態で呼び出される．p_lockに対して
ロックをの取得を試み，ロックが取得ができればリターン．ロックが取得がで
きなければ，一旦割込みを許可した後禁止して，ロックの取得を試みる．

(6-24-4-7) void x_release_lock(LockType *p_lock)

ロック解放関数．OS割込み禁止状態で呼び出される．p_lockのロックを解放す
る．

6.25 コア間割込みドライバ

6.25.1 コア間割込みドライバのファイル構成

コア間割込みドライバを組み込むための処理を，ターゲット依存部のコンフィ
ギュレーションファイル(target.tf)にて出力する．このファイルにて，コア
間割込みドライバを初期化するための初期化ルーチンの追加，コア間割込みを
停止させるための終了処理ルーチンの追加（必要ならば），コア間割込みのた
めの割込みハンドラの定義（または，割込みサービスルーチンの追加），コア
間割込みのための割込み要求ラインの属性の設定などを含むことになる．

コア間割込みドライバを呼び出すために必要な定義を含むヘッダファイルを，
target_ici.hに用意する．また，必要であれば，コア間割込みドライバの実装
ファイルをtarget_ici.cに用意する．

6.25.2 コア間割込みの初期化・終了処理・割込み処理

(6-25-2-1) void target_ici_initialize(uintptr exinf)

コア間割込みを初期化し，コア間割込み発行可能とする関数．この関数は初期
化ルーチンにて呼ばれることを想定している．必要としない場合は，用意する
必要はない．

(6-25-2-2) void target_ici_terminate(uintptr exinf)

コア間割込みを停止させ，コア間割込みを発生しないようにする関数．この関
数は，終了処理ルーチンにて呼ばれることを想定している．必要としない場合
は，用意する必要はない．

6.25.3 コア間割込みの発行とクリア

(6-25-3-1) void target_ici_raise(CoreIdType coreid)

コア間割込みを発行する関数．引数には割込み発生先のコアIDが指定される．

(6-25-3-2) void target_ici_clear(void)

コア間割込みをクリアする関数．コア間割込みを受け付けたコアのコア間割込
みハンドラで呼び出される．

6.25.4 コア間割込みハンドラの登録

共通部では，コア間割込みで呼び出される割込みハンドラ 
ici_handler_main() が用意されている．

この関数は，ターゲット依存部のコンフィギュレーションファイル
(target.tf)にて，割込みハンドラまたは割込みサービスルーチンとしてカー
ネルに登録された延長で呼び出されることを想定している．

6.26 コアコントロールブロック

ターゲット依存でコア毎に必要な変数は，ターゲット依存のコアコントロール
ブロック（TCCB）としてまとめ，CCB内でコア毎に生成される．TCCBの定義は
，target_ccb.hまたはそこからインクルードされるファイル（プロセッサ・チ
ップ・開発環境依存部で用意されるヘッダファイルなど）に含める．

target_ccb.hまたはそこからインクルードされるファイルには，以下の内容を
含める必要がある．

  ・前方参照用のCCBのtypedef宣言
    typedef struct core_control_block CCB
  ・TCCBの定義
  ・(6-14-1-1) CoreIdType x_core_id(void) の定義
  ・6.15.1 ロック方式 の指定
  ・6.15.2 ロック変数の型定義

6.27 ハードウェアカウンタ

ATK2-SC3から変更なし．

6.27.1 ハードウェアカウンタのファイル構成

ATK2-SC3から変更なし．

6.27.2 ハードウェアカウンタの情報提供

マルチコアにおいては，互換性向上のため，コア毎に，
"MAIN_HW_COUNTER_COREx"(x:コアID)というハードウェアカウンタを用意するこ
とを推奨する．

6.28 OSAP強制終了

ATK2-SC3から変更なし．


７．ジェネレータ設定ファイルのターゲット依存部

7.1 設定ファイルとターゲット依存部の位置付け

ATK2-SC3から変更なし．

7.2 パス2のテンプレートファイルのターゲット依存部

7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数

ATK2-SC3から変更なし．

7.2.2 ターゲット非依存部で定義される変数

(7-2-2-7)OSAP.CORE[osapid]	osapidのOSAPを割付けたコアを示す連想配列
(7-2-2-8)TMAX_COREID		コアIDの最大値

7.2.3 マルチコア関連の定義（関数）

以下に示すオブジェクト管理ブロック等の配置を制御するため，ターゲット依
存部のパス2のテンプレートファイルにおいて， カーネルの構成・初期化ファ
イル（Os_Lcfg.c に)おいて変数を宣言する関数を用意する．なお，これらの
関数を宣言しない場合は，特に配置指定を行わない変数の宣言が生成される．
引数は対象のオブジェクトのID番号である．これらの変数の多くは，ローカル
メモリないし，グローバルメモリに配置可能である．タスクスタックはプライ
ベートメモリに配置可能である．

  1.カーネルオブジェクトのコントロールブロックの配置場所
  2.カーネルオブジェクトのコントロールブロック以外のメモリ領域（タスク
    スタック等バッファ領域の配置場所

(7-2-3-1)  GENERATE_TCB(tskid)   タスク管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	TCB _kernel_tcb_$tskid$;$NL$

(7-2-3-2)  GENERATE_CNTCB(cntid) カウンタ管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	CNTCB _kernel_cntcb_$cntid$;$NL$

(7-2-3-3)  GENERATE_ALMCB(almid) アラーム管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	ALMCB _kernel_almcb_$almid$;$NL$

(7-2-3-4)  GENERATE_SCHTBLCB(schtblid) スケジュールテーブル管理ブロッ
									   クの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	SCHTBLCB _kernel_schtblcb_$schtblid$;$NL$

(7-2-3-5)  GENERATE_RESCB(resid) リソース管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	RESCB _kernel_rescb_$resid$;$NL$

(7-2-3-6)  GENERATE_ISRCB(isrid) C2ISR管理ブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	ISRCB _kernel_isrcb_$isrid$;$NL$

(7-2-3-7)  GENERATE_TSKSTK(tskid) タスクスタックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	static StackType _kernel_stack_$tskid$[COUNT_STK_T($TSK.STKSZ[tskid]$)];$NL$

(7-2-3-8)  GENERATE_SHARED_TSKSTK(coreid, shared_stkid, shared_stack_size) 
基本タスクの共有スタックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	static StackType _kernel_shared_stack_$shared_stkid$[COUNT_STK_T($shared_stack_size[shared_stkid]$)];$NL$

スタック共有される場合，共有されて使用されるタスクスタック毎に，
kernel.tf内でIDを割り振り，shared_stkidとなる．また共有するタスク毎の
スタックの最大値がshared_stack_sizeとしてスタックサイズになる．

7.2.4 コア毎のデータ構造の配置場所

ターゲット依存部のパス2のテンプレートファイルでは，ターゲット非依存部
をインクルードする前に，カーネルの構成・初期化ファイル（Os_Lcfg.c に)
おいて宣言されるカーネル内でプロセッサ毎に必要となる以下のデータ構造に
対して，配置先の指定のための関数を定義する．なお，これらの関数を宣言し
ない場合は，特に配置指定を行わない変数の宣言が生成される．

 1.CCB
   ・他コアからアクセス可能な領域に配置すること．
 2.OS用のスタック
    ・自コアからのみアクセスできる領域に配置可能．

(7-2-4-1) GENERATE_CCB(id) コアコントロールブロックの宣言関数

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	CCB _kernel_core$id$_ccb;$NL$

(7-2-4-2) GENERATE_OSSTACK_DEF(coreid) 
OS用スタックの宣言関数(スタックサイズ指定あり)

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	static StackType _kernel_core$coreid$_ostack[COUNT_STK_T($OSTK.STKSZ[OSTK.COREID[coreid]]$)];$NL$

OS用スタックは，コンテナOsOsStackで指定され，C2ISR,フック実行時に使用
されるスタック．

(7-2-4-3) GENERATE_OSSTACK(coreid, total_stksz)
OS用スタックの宣言関数(スタックサイズ指定なし)

未宣言の場合は，次のフォーマットで変数宣言が生成される．

	static StackType _kernel_core$coreid$_ostack[$FORMAT("COUNT_STK_T(0x%x)", +total_stksz[coreid])$];$NL$

total_stkszは，スタックサイズ指定がなかった場合に，必要な量をkernel.tf
内で計算した結果である．

7.3 パス3のテンプレートファイルのターゲット依存部

7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数

ATK2-SC3から変更なし．

7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル

ATK2-SC3-MCでは，target_cfg1_out.h（または，そこからインクルードされる
ファイル）に，典型的には，以下のような定義を含める必要がある．

----------------------------------------
int
main(void)
{
	return 0;
}

#define TotalNumberOfCores 1
StackType * const	_ostkpt_table[TotalNumberOfCores];

const uint8			MAGIC_1 = UINT_C(0x12);
const uint16		MAGIC_2 = UINT_C(0x1234);
const uint32		MAGIC_4 = UINT_C(0x12345678);

target_hardware_initialize(void)
{
}
----------------------------------------


８．システムモジュール等のターゲット依存部

8.0 システムモジュールのターゲット依存部

ATK2-SC3から変更なし．

8.1 システムログ機能のターゲット依存定義

ATK2-SC3から変更なし．

8.2 シリアルインタフェースドライバのターゲット依存部

8.2.1 変数，データ型，管理関数

ATK2-SC3から変更なし．

8.2.2 デバイスサービスルーチン

ATK2-SC3から変更なし．

8.3 カーネル起動メッセージの出力のターゲット依存定義

ATK2-SC3から変更なし．

8.4 サンプルプログラムとテストプログラムのターゲット依存定義

ATK2-SC3から変更なし．

8.5 実行時間分布集計モジュールのターゲット依存定義

ATK2-SC3から変更なし．

8.6 タイマドライバ

8.6.1 タイマドライバのファイル構成

ATK2-SC3から変更なし．

8.6.2 ソフトウェアカウンタの定義

ATK2-SC3から変更なし．

8.6.3 時間型の定義

ATK2-SC3から変更なし．

8.6.4 タイマの初期化・終了処理・割込み処理

ATK2-SC3から変更なし．

8.6.5 現在の時刻の取得

ATK2-SC3から変更なし．


９．その他

9.1 ドキュメント

(1) 対応しているターゲットシステムの種類・構成，バージョン番号
	・サポートしているコア数

(3-8) OS内部のロック単位
  ・ジャイアントロック と コアロックのサポート有無や選択方法．

(3-9) スピンロック方式
  ・ネイティブ方式 と エミュレーション方式 のサポート有無や選択方法．
    ネイティブ方式 の場合の最大数．

(3-10) メモリアーキテクチャ
  ・データの配置場所の制御方法．


１０．リファレンス

10.1 ターゲット依存部のファイル一覧

標準的なターゲット依存部のファイル構成は次の通りである．

target_ici.h	コア間割込みハンドラドライバのヘッダファイル（6.18節）．
				カーネルのみからインクルードされる．
target_ici.c	コア間割込みハンドラドライバの実装ファイル
				（6.18節，オプション）．
target_ccb.h	依存部のコアコントロールブロックのヘッダファイル
				（6.19節）．
以上
